## 进程和线程
浏览器是多进程架构，包含：
+ 浏览器主进程
+ GPU硬件进程
+ 插件进程
+ 网络进程
+ 渲染进程

我们通常所说的浏览器内核就是渲染进程，常说的blink排版引擎和执行JS的V8引擎就是属于浏览器内核，也就是渲染进程的。而渲染进程又是由多个线程组成的：
1. GUI渲染线程
2. JS引擎线性
3. 事件触发线程(专门轮询处理EventLoop的)
4. 定时器触发线程
5. ajax线程
6. DOM事件触发线程

几个注意点：
1. JS引擎线程和GUI渲染线程是互斥的，为了防止在渲染页面的时候JS又操作了DOM，引起渲染的紊乱。
2. 为什么说JS是单线程的？
准确的说是浏览器的JS引擎主线程是单线程的，假如有多个线程可以执行js，那么都去操作DOM，到底该听哪一个的呢？
3. JS引擎线程一次执行一个宏任务

事件循环的执行流程：
1. 脚本自上而下依次执行，这本身就是一个宏任务
2. 遇到同步代码，依次执行即可
3. 遇到异步代码，比如定时器，那就通知定时器触发线程，多少时间之后会触发，等时间到达之后就会将该定时器的回调函数推到事件队列上去，注意是吧回调函数推上去
4. JS主线程代码执行完成，首先看这一轮执行下来有没有产生微任务，如果有先把微任务队列清空
5. 然后依次去宏任务的消息队列上取出一个执行一个，注意在执行完一个宏任务之后首先清空微任务队列，然后在下一次宏任务执行前会通知渲染线程渲染一次页面
6. 然后执行下一个宏任务，周而复始所以叫做事件循环

## 长列表渲染优化思路
1. 暴力渲染最慢最卡
2. 定时器分片渲染，就是基于定时器是一个宏任务，每一次宏任务执行完成之后，在执行下一次宏任务的时候会渲染一次页面
3. window.requestAnimationFrame
4. document.fragment(IE浏览器需要文档碎片,现代浏览器已经实现了这个优化)
5. 虚拟渲染

## 暴力渲染
1. 新版本浏览器发现我们做的是重复的DOM操作的时候，浏览器不会创建一个节点插入一个节点到文档中，而是等js执行完成，将节点一次性插入到页面中。
2. JS的执行时间和渲染时间可不一样，JS执行10万条数据很快，但是渲染10万条数据到页面上是慢的。
3. script脚本本身就是宏任务，在执行脚本的过程中产生了定时器这个宏任务，在定时器这个宏任务执行之前会渲染一次页面，那么我们用定时器里面执行的时间点减去一开始的时间点，就是渲染的时间。

## 分片加载
会导致页面DOM元素过多 页面的卡顿和白屏
会一次性把元素全部创建到页面上来
分片渲染是基于浏览器事件循环机制，分割渲染时间

## 滚动懒加载
缺点还是最终会把所有DOM存在于页面上了

## 虚拟滚动
1. 列表定高
2. 列表非定高

时刻保证视图中看到