## 浏览器的多进程架构学习的必要性：
1. WEB前端性能优化
2. 浏览中的网络流程
3. 浏览器渲染页面的过程
4. 浏览器执行JS的流程
5. WEB安全理论

只有了解了浏览器的多进程架构，明白每一个进程的作用和内在机制，才可以在应对以上问题的时候知其然而知其所以然。前提都是Google的Chrome浏览器为默认浏览器进行分析。
## 一、Chrome浏览器的进程分析梳理
### 问题一：在谷歌浏览器中打开一个页面，会启动多少进程呢？
谷歌浏览器中————设置——————更多工具————打开任务管理器
谷歌浏览器中————按下快捷键shift+esc————打开任务管理器
谷歌的任务管理器是用来呈现谷歌浏览器当前的进程信息的，每一个任务管理器中的列表都是一个进程。
可以看出，打开一个页面至少需要5个进程。一个浏览器主进程、一个GPU绘制进程、一个渲染进程、一个存储进程、一个网络进程。如果有插件和Video等，还会有插件进程和Video进程，此外还有备用渲染进程。

### 问题二：计算机中的进程和线程是什么？你分的清楚么？
#### 单线程和多线程处理的性能对比
举一例：请计算下面三个表达式的值，并分别输出结果
```
a = 10*8;
b = 10-8;
c = 10+8;
```
如果是单线程处理，那么步骤会分为四步，只有上一步处理结束后才可以执行下一步：
1. 计算a的值为80
2. 计算b的值为2
3. 计算c的值为18
4. 分别输出a，b，c的值为80，2，18

但如果是多线程处理，那么步骤只需要两步就可以完成：
1. 假设计算机分配三个线程名为ABC，A线程处理a的值为80，B线程处理b的值为2，C线程处理c的值为18
2. 等待三个线程都处理完之后，分别输出a，b，c的值为80，2，18

可以很明显的看出，多线程的并行处理要比单线程的处理在性能上高很多。但是有一个问题需要注意，那就是多线程虽然好，但是线程是不能单独存在的，它必须由进程来启动和管理。

#### 什么是进程和线程？
一个进程就是一个程序的运行实例，当我们启动一个程序的时候(比如打开QQ音乐)，windows操作系统会为该程序(QQ音乐)创建一块内存，这个内存用来存放代码、存放程序运行时的数据，并且这个内存就是一个执行任务的主线程，我们把这样的一个由操作系统创建的用于程序执行时的运行环境称之为进程。

线程是依赖于进程的，而我们为了提高程序执行的效率，一般会在进程中开辟多个线程，因为多线程可以进行并行处理，大大提高程序执行的效率。

#### 线程和进程的5个关系特点
1. 线程是依赖进程来启动和管理的，不能单独存在

2. 各进程之间内容资源互相隔离，互不影响
线程之间共享所属进程的共有数据，但是各个进程之间的内容是完全隔离的。也就是每一个进程你只能访问自己进程中的数据，你访问不了其他进程的数据。这也保证了各个程序之间数据不会因为互相操作导致系统紊乱出错。

3. 同一进程多线程之间可共享公共数据
多线程之间可以共享进程中的数据，并且线程可以对进程的公共数据进行读写操作。前面说了，进程就是一块系统为程序执行创建的内存，这个内存的一大作用就是存储数据，所以进程中存放的公共数据是可以被线程所读写的，基于此可以实现线程中的数据通信。

4. 进程中线程出错，进程直接崩溃
进程中的任意一个线程出错，都会导致整个进程的崩溃，也就是当前进程中的其他线程也会出错

5. 进程关闭后，其所占内存会被完全回收
当一个进程关闭之后，操作系统会回收掉当前进程所占有的所有内存。就算其中某个线程因为操作不当造成了内存泄露，那么当进程退出的时候，这些内存也会被正确全部的回收。比如之前的IE插件很容易导致内容泄露，意味着浏览器开着的时候内存占有越来越多，但是一旦浏览器被关闭，这些线程中的内存也会被正确回收。


### 问题三：单进程浏览器和现在的多进程浏览器优缺点
#### 单进程浏览器的缺点
2007年以前的浏览器都是单进程浏览器。也就是浏览器中的所有功能模块都是运行在一个进程中的，比如网络、插件、JS运行环境、渲染引擎、页面等，这无疑会导致不稳定、不流畅、不安全三个缺点。
1. 不稳定
一个插件模块运行出错，会导致整个浏览器进程直接崩溃
渲染引擎模块在执行js代码的时候，js代码出错会导致整个浏览器进程的崩溃
2. 不流畅
所有模块都在一个进程中，最可怕的是还在一个线程中，很有可能一个js的死循环都会导致浏览器的卡顿，因为单线程最不好的地方就在于同一时刻只能做一件事。
3. 不安全
恶意开发者通过c c++开发的插件可以直接获取到系统的全部资源，当运行页面的时候插件被加载，它就可以获取你系统上的所有资源，并且可以释放病毒，窃取账号密码
#### 多进程浏览器都有哪些进程
最新版本的多进程浏览器有以下几个进程[Chrome版本为 91.0.4472.77（正式版本）]
+ 1个浏览器主进程（Browser）
主要负责界面显示，用户和浏览器的交互，下载资源，管理其他子进程，同时提供存储功能（最新版的已经将存储单独开辟了一个Storage进程去专门管理）

+ 1个GPU进程
最开始GPU进程的目的是为了实现3D CSS的效果，后来用户打开的网页、Chrome自己的UI界面都采用GPU来进行绘制。

+ 1个网络Nextwork进程
此进程主要负责页面的网络资源加载

+ 多个渲染进程
此进程是基于排版引擎Blink和JavaScript解析V8引擎，将HTML、CSS、JS解析渲染以及合成网页图片为用户可以与之交互的网页，默认情况下Chrome会为每一个打开的Tab标签创建一个渲染进程，所以打开了多少个页面，就会有多少个渲染进程，并且渲染进程是运行在沙箱模式下的。

+ 多个插件进程
此进程主要负责用户自定义安装的插件和拓展程序，由于插件比较容易引起崩溃，所以需要专门搞一个进程来管理，保证当插件进程崩溃后不会影响其他进程的正常执行。

+ 1个存储Storage进程
此进程主要用于管理浏览器的本地存储功能

+ 备用的渲染进程

#### 多进程浏览器架构有哪些好处以及其解决了哪些问题？
解决了之前单进程浏览器的不稳定、不流畅、不安全的缺点。
1. 各个进程之间是互相隔离的，解决了之前单一进程中某个线程的崩溃引起整个浏览器进程的崩溃。
2. JS也是运行在浏览器的渲染进程中的，就算JS代码阻塞了渲染进程，也只会影响当前页面的渲染，对浏览器中其他页面的渲染并不会产生影响，因为每一个Tab栏都有一个对应的渲染进程，各页面的渲染进程是互相隔离的。
3. Chrome将插件进程和渲染进程都锁在了沙箱中，这样就算恶意插件和JS脚本执行了，也不会突破沙箱去操作系统中的其他资源。

## 二、服务端返回的页面文件为什么能够被完整送达浏览器？
因为HTTP是基于TCP连接的，并且HTTP是应用层的，而TCP是基于传输层的，所以一个服务端返回的页面文件只要被传达到了客户端浏览器的应用层，那么数据的传输一定是完整的。
### 问题一：衡量一个前端页面的性能指标有哪些？
+ 用户体验指标：
请求一个网站时1s内看不到关键内容，用户产生任务被中断的感觉
用户点击按钮100ms内没有反馈，那么会感受到延迟
网页中动画没有达到60fps，那么用户会感受到动画的卡顿

+ 重要指标：FP(first paint) 
FP(first paint)代表从页面加载到首次开始绘制的时长，这个指标会直接影响用户的跳出率，而网络加载速度则是影响FP的重要指标，所以Web优化的核心是优化其页面的加载速度，这是目的。

要优化Web页面的加载速度，就要理解网络，理解网络就要理解网络协议。不管HTTP还是WebSockets协议都是基于tcp和ip协议的，而搞懂TCP/IP协议则有助于我们更加深刻的理解网络和web问题。
### 问题二：互联网体系中的协议
互联网世界是由一系列约定俗成的协议和理念组成的体系架构，只有各方都遵循这套协议，那么各方之间的通信才会变得毫无障碍，我们在此阶段需要掌握的网络协议有:

#### IP网际协议：Internet Protocal  把数据包送达目的主机
互联网上的任何设备都有一个唯一的地址，这个地址是一个唯一的数字。可以想象成家庭住址。计算机的地址称之为IP地址，访问任何网站的本质就是自己的计算机向另外一台计算机请求信息的过程。


在将一个数据包从主机A发送给主机B的过程中,在传输之前，此数据包会被附加一些信息，这些信息会被装在一个叫IP头的数据结构里，一般情况下IP头信息包含以下内容：
+ 目标IP地址 你得知道你向谁发送数据包
+ 源IP地址  你得让对方接受到你发的包之后方便找到你给你回复信息
+ IP版本
+ 生存时间等等

#### UDP协议：User Datagram Protocal 用户数据包协议 把数据包送达应用程序
IP是非常底层的协议，它只负责把数据包传输给指定的IP地址。但是传递给目标计算机之后，该计算机并不知道将这个数据包交给那个程序使用？是交给浏览器还是QQ音乐？因此，基于IP这种底层协议之上和系统的应用程序打交道的协议，最常见的就是UDP用户数据包协议。

UDP中一个重要的核心信息是端口号，它是一个数字。任何一个想访问网络的程序都需要绑定一个端口号，通过这个端口号UDP就知道把数据包发送给对应的程序应用了。
和IP头类似的是，端口号信息会被装入UDP头里面，UDP头再和原始数据包进行合并组成新的UDP数据包，一个UDP头通常包含以下内容：
+ 源端口号等信息  你得知道这个数据包是对面那个应用程序发给你的
+ 目的端口号信息  你得知道这个数据包交给那个应用程序
UDP传输的问题在于它并不能保证传输的可靠性，因为使用UDP在传输数据的时候，对于传输出错的数据包，虽然UDP可以校验数据是否正确，但是对于错误的数据包它会直接进行丢弃并不会有重发机制，而且UDP协议还有一个特点是数据在发送之后无法知道是否能够到达目的地。
UDP传输的好处也在于不会等待数据的重发，所以它的传输速度很快，这个特点也使得UDP协议成了那些对于数据完整性要求不高但是对数据传输速度要求较高的场景，比如在线视频，互动游戏等等。


#### TCP协议：Transmission Control Protocal 传输控制协议 把数据包完整的送达应用程序
前面说的UDP协议可以用来将数据包送达至应用程序，但是并不能保证数据包是完整的。而如果对于浏览器的请求、邮件的传输这类要求数据的传输可靠性和完整性很高的应用，如果使用UDP来传输，至少会存在以下两个问题：
1. 数据包传输中丢失了，UDP没有重发机制，导致数据不完整
2. 大的文件拆成小的数据包传输，这些小的数据包会经过不同路由，最终在不同时间到达接收端。UDP协议并不知道如何组装这些数据包，将其还原成完整的文件。

TCP协议就是用于解决以上问题的传输协议。它是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP协议相对于UDP的两个问题，有自己的两个特点：
1. 对于数据包丢失，TCP提供重传机制
2. TCP引入了数据包排序机制，保证将到达接收端的数据包按照顺序组合成一个完整的文件交由应用层

和IP头、UDP头一样，TCP头中包含了以下内容：
+ 目标端口号
+ 本机端口号
+ 用于排序的序列号，便于接收端按照序号组装数据包

#### TCP协议是如何保证重传机制和数据包的排序功能的？
答案就在TCP的连接过程中，一个完整的TCP连接生命周期包含三个阶段
1. 建立连接
此阶段通过三次握手来建立客户端和服务器之间的链接。
前面说了TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。这个面向连接的意思是在数据通信之前就要保证两端之间的准备工作，而专有名词三次握手就是指的在两端建立一个TCP连接的时候，客户端和服务器端总共要发送三个数据包才可以确认连接的建立。只有连接建立了，才可以开始后面的数据传递。


2. 传输数据
在此阶段，接收端需要对发送端发过来的每个数据包进行确认操作，也就是接收端在接受到数据包之后，需要发送确认数据包给发送端，告诉发送端我已经接收到你发的数据包了，是OK的。

如果发送端发送了一个数据包在规定时间内没有接收到接收端发送的确认数据包，那么则判定为这个数据包在传输的过程中丢失了，此时触发TCP协议的重发机制，发送端会将这个数据包再重发一遍。

一个大的文件被拆分成很多小的数据包发送给接收端的时候，接收端会按照TCP头中的序列号将其进行排序，便于组装成为完整的文件，并送达上层的应用程序。

3. 断开连接
在此阶段数据已经传输完毕，就要终止连接了。此阶段会有一个专业名词叫做四次挥手，四次挥手的目的是保证双方都断开连接。

TCP最大的特点是提高了数据传输的可靠性，但是其传输速度就没有UDP那么高，因为三次握手和数据包校验机制把传输过程中的数据包数量提高了一倍，我们要基于不同的应用场景，来合理的选择UDP协议或TCP协议，搞清楚他们都作为传输层通信协议的优缺点。

#### HTTP协议
HTTP协议是属于应用层的，而TCP协议是基于传输层的

### 问题三：一个数据包从发送端到接收端的流程
互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？

旅程一：数据包如何被送达至主机 基于IP协议的IP头
旅程二：主机如何将数据包转交给应用 基于TCP和UDP中端口号
核心过程：数据包是如何被完整的送达应用程序的 基于TCP的重传机制


>>> 基于简单的IP网络四层传输模型来理解一个数据包是如何从主机A传输到主机B的
1. 主机A 上层应用程序
上层将数据包交给传输层

2. 主机A 传输层：UDP协议和TCP协议
传输层会在数据包前面加上UDP头或TCP头，组成新的数据包，并将组装后的数据包交给网络层

3. 主机A 网络层：IP协议
网络层会将IP头附加在此数据包上，组成新的IP数据包，并交给底层

4. 底层
底层通过物理网络将数据包从主机A发送端传输至主机B接收端

5. 主机B 网络层
数据会被传输到接收端的网络层，在这里主机B会拆开IP头信息，并将拆开的数据部分交给传输层

6. 主机B 传输层
在主机B的传输层，主机B会拆开TCP/UDP头信息，并根据TCP/UDP头中的端口号，把数据包交给上层程序

7. 主机B 上层应用程序
最终，主机B上的应用程序就拿到了主机A的应用程序发给它的数据包，通信结束。

## 三、HTTP请求的8个流程分析

HTTP协议是应用层协议，是建立在TCP连接基础之上的。
HTTP协议是浏览器使用最广的协议，它是一种允许浏览器向服务器获取资源的协议，是WEB的基础。通常HTTP请求由客户端浏览器发起，用于获取不同类型的文件。

### 问题一：为什么通常第一次打开一个网页会很慢，第二次再去打开就很快？
因为第一次打开网页之后，DNS缓存和请求到的页面资源缓存这两部分数据是直接缓存在浏览器中的。
DNS的缓存比较简单，就是一个IP地址和域名的映射。
而浏览器缓存页面及资源的这个缓存cache可大有讲究，在此处总结一下。
+ 浏览器查找缓存的流程（浏览器三级缓存机制）

+ 服务器是如何通知浏览器缓存数据的？
当服务器返回响应数据的时候，在响应头中有一个字段名叫做Cache-Control来告诉浏览器是否应该缓存本次返回的资源。
通常情况下，我们还需要为需要缓存的资源设置一个缓存过期的时长，这个时长是通过Cache-Control中的Max-age参数来设置的，比如设置缓存过期的时间为2000秒。这意味着在2000秒以内浏览器再次请求该资源的时候不需要再向服务器发送请求，只需要从浏览器缓存中获取资源并加载即可。

如果超过2000秒之后去请求该资源，此时缓存资源已经过期，那么浏览器会发起一个HTTP请求，并且HTTP请求头中带上一个字段：If-None-Match："4f80f-13c-3a1xb12a"

服务器在收到这个请求头之后，会根据请求头中If-None-Match的值来检查请求的资源是否发送更新？
如果没有更新，返回304状态码 Not Modfild，告诉浏览器我没有改变，这个过期的缓存你可以继续使用，这次就不重新发数据给你了。
如果已经更新了，那服务器就返回最新的资源给浏览器。

综上所述：一个第二次打开的页面可以秒开，很大原因是浏览器将这些网页的资源缓存在了本地，在请求的时候浏览器直接从缓存中拿出副本来回应请求并将资源展示给用户，这个过程没有发生网络请求，自然节省了客户端和服务器通信的时间，同时DNS也被浏览器缓存了，这又进一步节省了查找IP地址的时间。



### 问题二：为什么登陆过一个网站之后，下次再访问这个网站就已经是登录状态而不需要重新登录了？这种登录态是如何做到的？
当浏览器在一个登陆页面首次进行登录的时候，输入了账号和密码，此时发起一个类型为POST的HTTP请求
浏览器构建请求行，然后将输入框中的信息当做请求体发送给服务器

服务器收到浏览器的请求，从数据库中查询用户账号和密码是否匹配。如果匹配，那么会生成一段表示用户身份唯一ID的字符串

服务器响应头中将Set Cookie字段的值设置为这个唯一ID的字符串，比如'UID=564dasdas'

浏览器接收到服务器的响应，并解析响应头。当看到有Set Cookie字段之后，那么浏览器会将这个唯一ID字符串保存至本地window.cookie中。

在下次进行访问的时候，浏览器就会将原本存储在本地的cookie字段中的数据写入到请求头的Cookie中，然后浏览器将请求头发送至服务器

服务器解析请求头时发现有Cookie字段，那么会取出这里面的数据。当解析到'UID=564dasdas'的时候，服务器从后台数据库查询，判断此用户已经是登录状态，然后生成含有当前用户自己信息相关的页面数据，并将数据发送给浏览器

浏览器接收到服务器的数据之后，开始解析并展示页面。

注意：为了避免恶意用户通过脚本获取到cookie数据，那么我们需要在cookie中加上httponly的属性，代表cookie信息无法被js脚本获取


### 问题三：浏览器端发起一个HTTP请求及响应的全流程
回答以上两个问题的关键在于搞清楚浏览器发起的HTTP请求的流程。(总共两端8个步骤)
比如我请求一个URL地址为：https://cn.vuejs.org/index/html的网页，那么详细流程如下：

1. 构建请求
浏览器构建请求行信息，构建好之后，浏览器就准备发起网络请求了。
请求行：请求方式+请求地址+协议版本三部分组成
GET /index.html HTTP1.1

2. 查找缓存【===> 浏览器的缓存专题】
在真正发起请求之前，浏览器会先在浏览器缓存中查询是否已经存在要请求的文件。
浏览器的缓存是一种在本地保存资源副本，以供下次请求时直接使用而无需发起重复请求的技术。
如果缓存中有：那么浏览器拦截请求，直接将本地资源拿来，不会去服务器再次请求，并结束请求
如果缓存中没有：那么在此，真正进入网络请求

3. 准备IP地址和端口
由于HTTP协议是应用层协议，用来封装请求的文本信息；而TCP/IP协议作为传输协议将它发到网络上，所以在HTTP工作开始之前，首先要做的是浏览器这个应用和服务器建立TCP连接，连接建立好之后HTTP请求行和请求头中的内容才可以被送达至服务器。得出一个结论：
浏览器发起一个HTTP网络请求的第一步是浏览器和服务器先建立TCP连接
那么建立连接需要哪些东西呢？
+ 源IP地址和目标IP地址是必须要有的，没有这个你找不到服务器所在的主机
+ 源应用端口号和目标应用端口号是必须要有的，没有这个就算你找到了主机你也不知道交给那个服务器程序处理数据
那么目标IP地址和端口号怎么获取呢？
已知我们现在有的信息是URL请求地址：[](https://cn.vuejs.org/index/html)
IP地址是一串诸如39.106.233.176的数字，为了方便记忆，出现了专门负责将难记的IP地址和好记的域名一一映射起来的系统，我们把这套系统称之为DNS域名系统(Domain Name System)。所以浏览器中输入域名之后的第一步不是先准备请求行信息，而是浏览器会基于URL中包含的域名请求DNS服务器返回域名对应的IP，并且浏览器还有DNS数据缓存服务，如果某个域名已经解析过了，那么浏览器会直接缓存解析的结果，以便于下次解析的时候直接拿来用，此处会减少一次向DNS服务器的网络请求。

而端口号就比较简单了，如果URL地址中没有特别指定端口号，那么就默认为80端口。

4. 等待TCP队列
Chrome浏览器中有一个机制，那就是同一个域名只能最多建立6个TCP连接，如果超出6个，那么后续的tcp连接会进入队列中等待。如果少于6个，那么直接进入下一步，建立TCP连接。

如果使用HTTP1.1协议进行请求数据，那么同一个域名下只能最多存在6个tcp链接，但是每一个tcp连接都是可以不断开进行下一次请求的，它是可以多次复用的。
如果使用HTTP2.0协议进行请求数据，那么浏览器只会为同一个域名维护1个tcp链接，因为HTTP2.0允许浏览器并行去请求资源。

一个tcp连接同时只能处理一次请求，那么如果一个网页有很多图片资源，那岂不是要等待好久才可以请求的到资源，正是基于此才有了CDN服务器。

5. 建立TCP连接
此处浏览器通过三次握手和服务器建立TCP连接，确认连接之后，就可以正式发起HTTP请求了。

6. 发送HTTP请求
上一步已经建立好了TCP连接，那么此时浏览器就可以正式和服务器进行通信了，而HTTP中的数据就是在这个通信过程中传输的。浏览器是以下面的步骤将请求信息发送给服务器的：
+ 首先发送请求行
请求行：请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议
目的是告诉服务器浏览器需要获取哪些资源，是基于什么HTTP版本协议的

+ 然后发送请求头Request Header
除了请求行之外，浏览器还需要将浏览器的一些基础信息等通过请求头的方式发送给服务器，一般的请求头中包含的字段有：
浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息
User-Agent：浏览器的操作系统及其内核
Accept：application/json, text/html 浏览器可以识别的文件类型
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 浏览器可以识别的语言类型
Connection: keep-alive 是否保持长连接
Cookie：每次都会将cookie发送给服务器，便于服务器识别身份
Host: time.geekbang.org 请求的域名信息

+ 最后发送请求体
如果是POST请求，浏览器还要准备数据给服务器，这里需要浏览器准备的数据就是通过请求体发送的

>>> 服务器端处理HTTP请求流程：
此时HTTP请求信息已经到达服务器了，服务器拿到请求信息之后开始准备返回给浏览器端的数据。
可以在终端使用curl -i https://time.geekbang.org/获取响应信息
1. 服务器返回响应数据给浏览器
服务器是按照下面的步骤将数据响应给浏览器的：
+ 首先返回响应行
响应行 协议版本 + 状态码 
HTTP/1.1 200 OK 
+ 其次返回响应头
服务器也会随同响应向浏览器发送响应头，响应头中包含了一些服务器自身的一些信息，如下：
Date: Sun, 06 Jun 2021 04:24:57 GMT 服务器生成数据的时间
Content-Type: text/html; charset=utf-8 返回的数据类型
Transfer-Encoding: chunked 
Connection: keep-alive
Vary: Accept-Encoding
Set-Cookie: gksskpitn=68f6bf2a-0721-4b20-9ffa-9a95a3b5132f; Path=/ 服务器要求在客户端保存的cookie等信息
Strict-Transport-Security: max-age=15768000
+ 最后返回响应体
前端浏览器拿来解析的HTML页面就是存在于响应体中的，一般情况下调API接口后端返回的JSON对象也是存在于响应体中的。


2. 断开连接
至此，服务器已经向浏览器返回了请求数据，此时服务器就要关闭TCP连接。
而如果浏览器或者服务器在其头信息中加入了：Connection：Keep-Alive。这表示本次TCP连接在发送后任然保持连接状态，这样浏览器就可以继续通过同一个TCP连接请求数据，这样做最大的好处是保持TCP连接可以节省下次请求时需要三次握手建立TCP连接的时间，大大提高资源的加载速度。

3. 重定向

还有一种特殊情况是如果服务器返回的状态码是301，代表告诉浏览器我需要重定向到另外一个网址。而这个网址则包含在返回的响应头中的Location字段，请浏览器拿到该字段中的网址并导航至该页面。这样的好处是就算用户在地址栏中只输入hupu.com；最终也会跳转至www.hupu.com。
C:\Users\克林辣舞>curl -I hupu.com
响应行 
HTTP/1.1 301 Moved Permanently
响应头 Response Header
Date: Sun, 06 Jun 2021 06:39:17 GMT
Content-Type: text/html
Content-Length: 185
Connection: keep-alive
Location: https://www.hupu.com/
X-Server: fd301-web-1-95-prd.vpc
Set-Cookie: SERVERID=6dada98b39769b30efd5a6c896f8c8b2|1622961557|1622961557;Path=/

## 四、一个页面从输入URL到页面呈现，这中间发生了什么？
从输入URL到最终的页面呈现，这整个过程需要浏览器各个进程之间的密切配合，最终才可以实现页面展示。
下面就从浏览器各进程在不同时间段所执行的任务，来详细说一下这个流程。

浏览器进程：负责页面展示、用户交互、管理其他子进程
网络进程：  负责从网络上下载资源
渲染进程：基于排版引擎Blink和JS解析引擎V8将从网络下载的HTML、CSS、JS以及图片等资源解析渲染为可以和用户交互的页面。渲染进程所有内容都是网络下载的，所以可能存在恶意代码利用浏览器对系统进行攻击，所以此进程是运行在沙箱里面的，至少在Chrome中是这样的。
### 第一步：用户在浏览器地址栏中输入内容
如果输入的是搜索内容，那么地址栏会使用浏览器默认的搜索引擎来合成一个带有该搜索内容的URL
如果输入的是URL地址，那么地址会自动在这个URL地址前加上协议，合成完整的URL

>>> 注意：window.onbeforeunload事件拦截页面跳转
在上一步URL地址准备好之后，浏览器还给了当前页面一次执行onbeforeunload事件的机会。window
.onbeforeunload事件允许页面在退出之前执行一些数据清理操作，类似于Vue中的beforeDestory生命周期，在onbeforeunload事件的回调函数中，可以进行数据清理，询问用户是否离开此页面等等，也就是说这个onbeforeunload事件可以拦截页面跳转。

### 第二步：URL请求过程 主要在网络进程中执行
此过程中，首先浏览器进程会通过进程间通信（IPC）把URL请求发送给网络进程，在浏览器的网络进程中，才会真正的发起URL请求流程。

以下是网络进程中进行URL请求的主要流程：
1. 网络进程查找浏览器本地缓存cache中是否缓存了该资源
有缓存，直接拿本地缓存副本资源，请求被拦截
无缓存，则进入下一步网络请求流程

2. DNS查询IP地址，如有必要建立TLS连接
浏览器缓存中是否有DNS查询记录，如果有，直接拿来；否则依次向系统缓存、路由器以及根域名服务器进行查询，获取到服务器IP地址
如果本次请求为HTTPS请求，那么还需要建立TLS连接

3. 基于获取的IP地址，浏览器同服务器建立TCP连接
此处进行三次握手，确认连接

4. 确认连接之后，开始传输数据
+ 浏览器发起HTTP请求
构建请求行、发送请求头和请求体，将Cookie等基本信息附加在请求头中一起发送给服务器
+ 服务器收到请求，做出响应
服务器收到请求后，根据请求信息生成响应数据。包含响应行、响应头、以及返回的响应体，返回的资源是否需要缓存、是否需要设置Cookie等信息都是包含在响应头信息中一起发送给浏览器。
+ 浏览器接收到服务器的响应信息，读取解析响应行和响应头信息
>>> 先解析响应行中返回的状态码
返回状态码为301或302，代表服务器需要浏览器重定向至响应头中字段为Location的URL地址，此时浏览器会读取并拿到这个URL地址，并基于这个地址重新发起一个新的HTTP请求，一切又从头开始了。

返回状态码200，代表一切OK，浏览器可以处理返回的数据了

返回状态码为403，代表过期资源并未发生变化，本次请求不返回新数据，请浏览器直接从本地缓存中拿

>>> 再解析响应头中返回的字段Content-Type
Content-Type:此字段代表服务器告诉浏览器我给你返回的是什么类型的资源，浏览器需要根据此字段中资源的类型决定如何显示响应体中的内容。一般情况下服务器会根据浏览器请求头中的Accept返回对应的数据类型。

Content-Type字段常见的值有：
+ text/html 返回的资源是HTML格式
+ text/plain 纯文本格式
+ image/png png图片格式
+ application/json 返回的资源是JSON对象
+ application/xml  XML数据格式
+ application/octet-stream 返回的资源是字节流类型，文件下载。那么该请求会提交给浏览器的下载管理器进行下载，同时URL请求流程到此终止。如果是HTML，那么浏览器会进行渲染进程的准备工作。
+ application/x-www-form-urlencoded form标签默认的content-type，对表单中的值进行转化编码后拼接成为key-value对
+ multipart/form-data 在表单中进行文件上传的时候，需要使用此格式

### 第三步：浏览器进程通知渲染进程准备渲染

Chrome默认为每个标签Tab页开启一个渲染进程。但是如果我们从A页面打开了B页面，这两个页面属于同一站点的话，那么新页面会复用旧页面的渲染进程；如果两个页面不属于同一个站点，那么会分配一个新的渲染进程。

1. 同一站点的定义
把拥有相同协议(HTTPS/HTTP)和相同根域名的URL称作同一站点，同一站点的页面渲染在是在一个渲染进程中的。

2. 同一站点举例
根域名：geekbang.com
协议：https
所以以下三个URL地址都属于同一站点，因为他们的根域名和协议都相同，只不过是子域名和端口不同而已。
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080

### 第四步：文档提交阶段 三个进程之间的配合

当网络进程中在拿到服务器返回的数据并解析响应头数据的时候，网络进程就先将响应头数据转发给了浏览器进程，此时网络进程依然在读取响应体的数据。

浏览器进程接收到响应头信息之后，也就是向渲染进程发起一个提交文档的信息，通知渲染进程开始准备

渲染进程接收到通知之后，开始准备接收HTML数据，接收数据的方式是直接和网络进程建立管道，只要网络进程拿到HTML数据就会提交给渲染进程这里。

渲染进程接收完网络进程的数据之后，向浏览器进程发送确认提交文档的信息，告诉浏览器进程，我已经准备好解析HTML页面数据了，此时浏览器进程便会将此前页面移除，更新浏览器界面状态、地址栏url、前进后退的历史状态自己更新WEB页面。

### 第五步：渲染阶段 渲染进程
一旦文档被提交，渲染进程就是立即开始进行页面解析和子资源加载了。一旦页面生成完成，渲染进程会通知浏览器进程页面已经解析完成，此时浏览器左上角loading动画结束，一个完整的页面到此就生成了。
+ 每个阶段都有其输入内容
+ 每个阶段都有其处理过程
+ 每个阶段都有其输出内容

1. 构建DOM树阶段
这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
浏览器渲染引擎Randering Engine解析HTML文档并构建一个DOM树，DOM树的构建过程是一个深度遍历的额过程，当前节点的所有子节点都构建好才会去构建当前节点的下一个兄弟节点。所以我们在写HTML的时候，不要将结构嵌套的太深。
2. 样式计算阶段 Recalculate Style
+ 渲染引擎会将所有途径获取到的CSS文本转换为浏览器可以理解的结构——styleSheets，此结构具备了查询和修改功能，为后续的样式操作打下基础。
+ 将styleSheets样式表中的属性值进行标准化操作，将所有值转换为渲染引擎容易理解的、标准化的计算值，这过程称之为属性值标准化。如rpx、bold等转化为标准属性值
+ 基于CSS的继承性和层叠性这两大规则，计算出DOM树中每个节点的具体样式，此阶段输出的是计算之后的每个DOM元素最后的样式，可以在谷歌浏览器的控制台Computed中查看，也可以调用window.getComputedStyle(DOM元素对象)方法获取某个DOM元素的全部样式。

3. 布局阶段LayoutTree
有了DOM树，还有了DOM树中元素的样式，但是还不能显示。因为浏览器不知道每一个DOM元素具体的几何位置信息。
把计算DOM树中可见元素的几何位置的计算过程就做布局，此阶段中需要完成两个任务：创建布局树和布局计算。
+ 创建布局树
浏览器遍历DOM树中的所有可见节点，并将这些可见节点构成的DOM树和CSS树进行合并生成一个布局树。诸如head标签中内容以及display：none属性的元素会在遍历的时候被忽略。

+ 布局计算
接下来，浏览器基于生成的布局树，计算出各节点具体的几何位置信息，并将这些信息保存在布局树中。

4. 分层阶段
如果页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）
+ 拥有层叠上下文属性的元素会被提升为单独的一层：比如开启fixed和absolute定位的元素、定义透明属性的元素、使用CSS滤镜的元素，会被提升为单独的一层。
+ 需要剪裁（clip）的地方也会被创建为图层：比如出现滚动条，那么滚动条会分层；比如当文字在固定大小和盒子中展示不下需要换行和打点隐藏的时候会出现层。

5. 图层绘制阶段
在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，具体流程渲染引擎是会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，然后交给渲染进程中的合成线程处理。

6. 栅格化阶段
绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。通常，合成线程会先将图层划分为小的图块，然后合成线程会按照用户视口优先的原则，将图块转化为位图，这个操作就是栅格化，一般情况下GPU进程会加速完成图块转化为位图的栅格化操作，并将生成的位图保存在GPU进程的内存中。


7. 合成和显示阶段
一旦所有图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

## 五、如何减少页面回流和重绘？
重绘：通过JS和CSS更新了页面元素的绘制属性，比如背景颜色，文字颜色，边框颜色等，此时会导致页面重新进行绘制，省去了布局和分层的阶段，所以开销较小。

回流：通过JS或者CSS修改页面元素的几何位置属性，会触发页面重新布局，也就是需要重新生成一个布局树并计算各DOM元素的几何位置，这个过程叫做回流，对浏览器的开销最大。

合成：修改了一个既不要绘制也不要布局的属性，渲染引擎会跳过布局和绘制，只执行最后的合成操作。比如CSS3的transfrom：translate(50px);由于位移的操作不会影响页面上任何元素的布局位置，而且也没有改变元素背景等颜色，那么这种操作只会合成，对浏览器的性能影响最小。

## 晚上需要完善的点：以面试为主 下来再深入研究
1. eventLoop 宏任务 微任务
2. 前端安全
3. 前端缓存 以有大致了解 可深入
4. 两种路由的背后原理（已经了解和总结）
5. 前端性能优化
6. HTTP2.0基本一些知识


## 六、浏览器的消息队列和事件循环机制
渲染进程中的主线程非常繁忙，要处理DOM，要计算样式，处理布局，还要处理JS任务以及各种输入事件，如何让这么多不同类型的任务在主线程中有条不紊的执行，这就需要一个系统来统筹调度这些任务，这个统筹调度的系统就是浏览器的消息队列和事件循环系统。

在单线程中处理预先安排好的任务，只需要按照代码顺序自上而下的执行即可，执行结束后线程退出。
但是在单线程中处理任务的时候，如果在处理预先安排好任务的时候又新任务加入，此时就需要用到事件循环机制。
1. 引入循环机制 保证主线程可以循环往复去事件队列的头部取出宏任务，放到主线程上执行
2. 引入事件 可以在线程运行的过程中，去等待事件的执行。事件一旦执行，主线程马上激活，然后执行

渲染进程中有渲染主线程以及IO线程：
渲染主线程用来执行任务
IO线程用来接收其他进程和线程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程

当渲染主线程接收到IO线程发过来的一些任务之后，比如接收到资源加载完成的任务此时主线程就要进行DOM解析，接收到鼠标点击事件等，此时主线程就要执行响应的JS代码来处理点击事件了。那么怎么设计一个线程模型，让其能够接收其他线程发送的任务呢？

答案是消息队列。消息队列是一种数据结构，它可以存放要执行的任务。其特点是先进先出，也就是要添加任务，请添加到队列的尾部；要取出任务，请从队列头部去取。

此时，原先渲染进程中的IO线程就和渲染主线程有了沟通的桥梁，这个桥梁就是消息队列。具体原理是：
IO线程中产生的新任务，会被依次添加到消息队列的最尾部；然后渲染主线程循环往复的去消息队列的头部取出任务，放到主线程上进行执行。


消息队列中的任务类型
内部消息类型：
输入事件，如鼠标滚动、点击、移动
微任务
文件读写
WebSockets
Js定时器等

与页面有关的事件
JS代码执行
解析DOM
样式计算
布局计算
CSS动画等

以上这些任务都是在主线程中执行的，我们的重点是JS代码执行这块。
页面单线程执行的缺点：
1. 由于所有执行的任务都来自于消息队列，消息队列是先进先出的属性，只要前面没有执行完，后面的会一直处于等待状态。此时问题出现了：该如何处理优先级更高的任务？
比如监控DOM节点的变化，当DOM节点发生改变的时候，渲染引擎同步调用JS接口，来处理响应的业务逻辑。但是如果DOM变化非常频繁，那么如果每次发生变化的时候，都调用对应的JS接口，那么这个任务执行的事件会被拉长，效率下降。
如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。
也就是如果采用同步通知的方式，会影响当前任务的执行效率；如果异步方式，又会影响到监控的实时性。
基于此产生了微任务。
通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。
等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。
每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，等宏任务快执行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别！
JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的！
基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术
#### 浏览器的宏任务和微任务
页面中大部分任务都是在渲染主线程上执行的，比如：
渲染事件（解析DOM、计算样式、计算布局、绘制页面等）
浏览器原生用户交互事件（鼠标点击 滚动页面 放大缩小窗口等）
JS脚本执行事件
网络请求完成
setTimeout 函数触发的回调函数都是宏任务

为了协调来自不同线程和进程的任务在一个渲染主线程上有条不紊的执行，浏览器引入了消息队列和事件循环机制。而且渲染进程内部会维护多个消息队列，普通的消息队列和延迟执行的消息队列（定时器就是在这个延迟的消息队列上）。渲染主线程循环往复的去消息队列的头部取出任务放到主线程上执行任务，我们把这些消息队列中的任务称之为宏任务。

宏任务可以满足我们日常的大部分需求，但是有一种情况是这样：将各种不同的任务添加到消息队列的这个操作是系统完成的，并不受我们前端JS的控制，也就是JS并不能控制一个任务要添加到队列中的位置，以及开始执行该任务的时间。比如我们设置两个定时器：
理想的状态是demo2执行的时候，触发定时器1，并将demo1执行。但是两个定时器的回调函数都是宏任务，这两个宏任务之间你并不能保证没有其他线程和进程的宏任务进来，如果这两个任务中间插入了其他任务，那么第二个定时器的执行时间就会收到影响。
所以宏任务的缺点就是时间粒度比较大，两个宏任务之间的执行间隔是不能被精确计算的，因为消息队列中的都是宏任务，添加一个任务到消息队列是系统完成的。所以基于此，对于一些高实时性的需求，比如监听DOM变化，我们就要用到微任务。

什么是微任务？
微任务和异步回调函数一样，是一个需要异步去执行的函数，微任务的执行时机是主函数执行结束后、当前宏任务结束之前。

说每个宏任务都关联了一个微任务队列
微任务是如何产生的？
使用Promise，当调用Promise.resolve()或者reject()的时候会产生一个微任务
使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。

执行微任务队列的时机
在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务，取出当前微任务队列中的任务，放到当前宏任务中执行。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。
```js
function demo1(){
	console.log(22);
}
function demo2(){
	console.log(11);
	setTimeout(demo1,0);
}
setTimeout(demo2,0);

```


#### JS引擎中的宏任务和微任务



宏任务是开会分配的工作内容，微任务是工作过程中被临时安排的内容，可以这么比喻吗？
部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。
JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！

以上就是微任务的工作流程，从上面分析我们可以得出如下几个结论：
微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。