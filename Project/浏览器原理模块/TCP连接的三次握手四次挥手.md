## 准备知识
TCP协议存在的目的是将数据包完整的送达至应用层，TCP协议是基于传输层的。而它要找到应用层，必须要找到目标应用程序的端口号。
1. TCP报文的格式及内容介绍
源端口号和目的端口号  用于将数据包发给目的应用
SEQ Number序列号：用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
Ack Number确认号：只有当ACK=1的时候生效，表示期望收到的下一个字节的序号。ack=seq+1
标志位Flags：总共有6个，具体含义如下所示：
URG：紧急指针有效
ACK：代表确认序号(Ack Number)有效
PSH: 代表接收方应该尽快将此报文交给应用层
RST：代表连接重置
SYN：代表发起一个新连接
FIN：代表释放一个连接

确认方的Ack确认序列号=发起方的Seq序列号+1，两端一定是配对的。

## TCP连接三次握手
1. 为什么要进行三次握手？
由于TCP并不存在连接的概念，只存在请求和响应，请求和响应都是数据包，数据包的传输是基于由TCP创建的一个从客户端发起，服务端接收的连接通道，HTTP请求作为应用层的协议，是在TCP连接的基础上发送的。

HTTP 1.0 TCP连接是在HTTP请求创建的过程中同步建立的，HTTP请求服务器响应之后，那么TCP连接就会关闭。
HTTP 1.1 服务端可以在返回的HTTP响应报文中声明Connect：keep-alive，代表这个tcp是长连接，那么第二			次发起请求的时候就不需要再进行三次握手了，节省连接的时间。 
HTTP 2.0 支持一个TCP连接里并发的传输HTTP请求，HTTP1.0中浏览器对其支持为1个域名最多6个TCP链接，            后续的请求进入TCP队列中等待。

### 三次握手详解 三次握手就是发了三次报文
1. 客户端向服务端发送一段TCP报文，其报文的内容大致为：
标记位是SYN，代表客户端请求建立TCP连接
首次序号为Seq=X，首次序号一般是随机的
随后客户端状态为SYN-SENT阶段

2. 服务器端收到来自客户端的TCP报文之后，并返回一段TCP报文：
标志位是SYN和ACK：其中ACK代表服务器告诉客户端，你发过来的序列号是有效的，我可以接收到你发的数据。SYN表示服务器告诉客户端同意建立TCP连接。
序号为Seq=Y
确认号Ack = 客户端发过来的Seq+1。注意这个确认号Ack NUmber和ACK确认序号有效的标志位是不同的东西，还有+1表示告诉客户端我收到你的序列号了，并给他+了1作为自己确认号的值发给你。
此时服务器进入SYN-RCVD阶段

3. 客户端收到服务端的TCP报文后，明确了客户端至服务端的数据传输正常
此时客户端结束之前的SYN-SENT阶段，并发给服务器最后一段TCP报文：
标志位是ACK：代表客户端告诉服务端，确认收到服务端确认建立TCP连接的信号
序号为Seq=X+1:代表客户端收到服务端返回的确认号Ack的值，并将其当做自己的序列号
确认号为Ack=Y+1：代表客户端收到服务端的序号Seq=Y了，并将其值加1作为自己确认号Ack的值
客户端进入ESTABLISHED阶段（已确认的）

随后服务器收到客户端发过来的TCP报文，确认双方连接通道正常，服务器结束SYN-SENT状态，进入ESTABLISHED阶段（已确认的）

客户端和服务端传输的TCP报文中，双方的Seq序列号和Ack确认号都是在对方的Ack和Seq基础上+1的，这样一来保证了TCP报文传输的连贯性，一旦某一方发出的TCP报文由于网络等原因丢失，便无法继续握手了，基于此确保了三次握手的顺利完成。


### 为什么是三次握手，不能是二次握手？
### TCP四次挥手的详解
TCP的四次挥手指的是TCP连接的释放解除。必须是一方主动释放，另外一方被动释放，以客户端主动发起释放连接为例：

1. 客户端结束ESTABLISHED阶段，向服务端发送一段TCP报文
标志位FIN:代表客户端请求释放连接
序列号Seq=U
客户端进入FIN-WAIT-1阶段，即半关闭阶段。此状态下客户端停止向服务端发送数据，但是客户端还是可以接受服务端传输过来的数据。

2. 服务端接受到TCP报文，确认了客户端想要释放连接
此时服务端也结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回TCP报文：
标志位ACK:代表确认接受到客户端发起的释放请求
序列号Seq=V
确认号Ack=U+1
随后服务器开始准备释放服务端到客户端方向上的连接，

客户端收到服务端的TCP报文之后，确认了服务端已经收到了客户端的释放连接请求，此时客户端首先结束之前的半关闭状态FIN-WAIT-1阶段，进入FIN-WIAT-2阶段，此时关闭客户端到服务端的TCP连接。

3. 服务端发出带有ACK的确认报文之后，经过CLOSE-WAIT阶段，做好了释放服务端到客户端的方向上的连接准备，此时再次向客户端发送一段TCP报文：
标志位FIN+ACK:代表服务器告诉客户端我已经准备好释放TCP连接了
序列号Seq=W
确认号Ack=U+1

随手服务端结束CLOSE-WAIT阶段，进入LAST-ACK阶段，并且停止在服务器端到客户端方向上发送数据，但是服务端依旧可以接受到从客户端传输过来的数据。

4. 客户端收到服务端发出的TCP报文，确认服务器已经做好释放连接的准备了
此时客户端结束FIN-WIAT-2阶段，进入TIME-WAIT阶段，并向服务端发送最后一段报文：
标志位ACK:代表客户端接收到服务端准备好释放连接的信号了
序列号Seq=U+1，将服务端返回的确认号当做本段报文的序列号
确认号Ack=W+1，将服务端返回的序列号+1当做本段报文的确认号
随后客户端开始在TIME-WAIT阶段等待2MSL

服务端收到客户端的报文之后结束LAST-WAIT，进入CLOSED阶段，服务端正式关闭服务端到客户端方向上的连接。

客户端等待2MLS之后，结束TIME-WAIT阶段，进入CLOSED阶段，四次挥手结束。

服务端发出第二次报文之后，如果一段时间内没有收到客户端的TCP报文，那么就会再次发一个报文给客户端。

客户端在发出第二次报文之后，如果一段时间内没有收到服务端的响应，那么就默认为服务端已经关闭连接了；如果这段时间内继续收到了服务端的响应，那么代表服务端没有收到自己的第二次报文，此时需要重新发一个TCP报文，并设置一段时间内是否有收到服务端的响应。

### 为什么握手是三次，挥手是四次？
