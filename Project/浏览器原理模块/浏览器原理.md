## 专题之浏览器url输入到页面呈现
此专题引申出了前端浏览器和网页HTTP的以下知识点：
1. DNS域名查找的顺序
2. 客户端发起一次HTTP请求，都包含哪些部分组成？
3. 服务器返回的响应中，都由哪些部分组成？
4. 服务器返回的响应状态码中，常见的状态码都有哪些？
5. 客户端和服务端的三次握手四次挥手是怎么一回事？
6. 浏览器的各个进程是如何配合加载渲染HTML页面的？
7. 什么是回流？什么是重绘？哪些操作会造成回流和重绘？如何减少回流和重绘？
8. 服务器返回的哪些文件会阻塞页面？哪些文件不会？

### 17.从输入url到页面显示这个过程中，浏览器做了什么？
1. 第一步首先是输入网址并按下回车键，比如输入了www.taobao.com

2. 浏览器开始查找输入域名(www.taobao.com)所对应的IP地址
首先第一步是基于DNS(Domain Name System域名系统)把要访问的域名的IP地址查询出来
DNS查询的过程如下：
01. 先从浏览器缓存查询，因为浏览器会缓存DNS记录一段时间，但是操作系统并不会告诉浏览器存储DNS记录的时间
02. 再从系统的缓存中进行查询，浏览器在此时会基于window.gethostbyname的api发起一个系统调用，从系统缓存中查询是否有存在当前访问域名的ip地址
03. 然后再从路由器缓存中查询，此时会将上一步的查询请求发送给路由器，因为路由器一般会有自己的DNS缓存
04. 然后再从ISP网络服务提供商缓存DNS的服务器进行查询，ISP的DNS服务器会从根域名服务器开始循环遍历查找当前域名对应的ip地址，一般情况下DNS服务器的缓存中是存在顶级域名.com中的域名的。所以这一步会活得ip地址，域名解析到此结束。

基于IP地址和服务器建立tcp连接，如果浏览器的tcp连接请求超出6个，那么需要等待

3. 浏览器给对应的web服务器发送一个HTTP请求
HTTP请求由三部分组成，请求行 请求头和请求正文
+ 请求行由请求方式 请求地址 HTTP协议版本 
Method Request-URL HTTP-Version CRLF 
+ 请求头 Request Header
客户端向服务器附加的一些信息和客户端自己的一些信息
Cookie
Accept  application/json
User-Agent
Authorization
token
Content-Type text/html  application/json
+ 请求正文
请求的时候要发送给服务器的对象

4. web服务器给浏览器响应一个301永久重定向响应
服务器给浏览器响应一个301永久重定向响应，将重定向的地址放在响应头的location字段中

为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？
其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.baidu.com/和http://baidu.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有一个是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。

5. 浏览器跟踪服务器返回的重定向地址

现在，浏览器知道了要访问的正确地址就是服务器返回的重定向地址，所以它会基于这个新的地址发送另一个http请求。请求头部一般包括：
Accept：application/x-ms-application, image/jpeg, application/xaml+xml
Accept-language：en-US
Accept-Encoding：gzip, deflate
Connection：Keep-Alive
User-Agent：Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]
Cookie：lsd=XW[...]; c_user=21[...]; x-referer=[...]
Host： www.facebook.com
6. 服务器处理客户端请求并作出响应

7. 服务器返回一个html页面

8. 浏览器开始解析html页面(具体如何解析呈现见下文)
### 18.浏览器接收到一个HTML文档之后是如何解析呈现给用户的呢？（渲染流水线）
首先要知道服务器返回的一般都是HTML文档、css样式表、JS文件、图片文件等，基于这些文档和图片浏览器才会构建出一个页面呈现给用户。

然后我们需要知道浏览器在接受到这些内容之后是如何加载？如何解析以及如何渲染的？

最后还要知道加载渲染以及解析的顺序是那个前那个后？

因为只有彻底搞清楚以上这些内容之后，才可以帮助我在日常的开发中快速定位问题以及针对浏览器渲染这块内容做优化的时候有的放矢。
理解浏览器是如何进行加载的：可以让我们知道在引用外部css表和外部js文件的时候，将它们放在不同的位置，便于浏览器以最快的速度将文件加载完毕

理解浏览器是如何进行解析的，可以在构建DOM结构、选择css选择器的时候选择最优雅的写法以便于提高浏览器的解析效率

理解浏览器是如何进行渲染的，可以在设置元素属性，通过js操作DOM的时候尽可能的减少重绘和回流对于性能的销毁。

浏览器解析HTML页面的几个大前提：
1. 浏览器为了更好的用户体验，浏览器会边解析边渲染，它不会等到把所有HTML文档解析完成之后才开始构建和布局渲染树，而是先拿到一部分HTML文档开始渲染。
2. 在浏览器渲染的过程中，浏览器很有可能正在在网络上下来其他文件。
3. 浏览器的渲染是单线程的，是自上而下渲染HTML文档的
4. 浏览器在自上而下解析HTML页面的时候，如果在head中遇到一个link标签引用了外部的css，此时浏览器会发起一次请求该css样式文件的请求，所以此处会造成HTML解析的阻塞。
5. 接着继续执行，当遇到一个img图片标签的时候，浏览器又会发起一个图片的请求，但是图片的请求不会阻塞浏览器的加载，也就是浏览器不会等到图片下载完成之后再解析，而是继续自上而下进行解析。
6. 让服务器返回了图片文件，浏览器发现这个图片会导致重新计算布局等因素，所以需要回过头来重新渲染这部分代码。
7. 当浏览器遇到一个script标签，浏览器JS引擎会立马解析并执行JS文件，因为我们的js文件很有可能包含修改DOM布局及位置的代码，所以浏览器在解析js代码的时候又会发现这部分js代码会造成页面布局变化，所以又回过头来重新渲染。
所以说script标签最好放在body元素的最底端，因为这样会等到所有DOM到加载完成之后，才去执行JS代码，避免渲染过程中出现多次回流和重绘。如果不想放在底端，也可以在js代码中写上一个window.onload事件，此事件代表当页面中的所有元素（包括图片等资源）都加载完成了，此时才去执行js代码，或者可以调用window.onDOMContentLoaded事件，此事件代表页面中的DOM结构都加载完成了，但是不支持IE9，是HTML5新增的事件。
还可以使用jquery的$(document).ready(function(){}),其简写为$(function(){}),这和window商的onDOMContentLoaded类似，都是当DOM加载完成就执行的方法。区别在于window.onload只可以绑定一个回调函数，而这个$(function(){})可以绑定n多个回调函数
还可以使用document.onreadystatechange事件来判断，当document.readyState的状态等于complate的时候，也代表当前页面加载完成了，因为再ie中没有window.onload事件，只有此事件。
+ 浏览器遇到多个script标签的时候，也只会先发起请求获取这个js文件，并将这个js代码立即执行，并不能并行去下载和解析多个js文件，所以浏览器在解析script标签的时候也是会阻塞的浏览器后续渲染的。
+ 如何实现无阻塞下载js的方法
采用script标签的defer属性
动态创建一个script标签来下载执行代码

浏览器渲染HTML页面步骤详解：
1. 浏览器渲染引擎Randering Engine解析HTML文档并构建一个DOM树，DOM树的构建过程是一个深度遍历的额过程，当前节点的所有子节点都构建好才会去构建当前节点的下一个兄弟节点。所以我们在写HTML的时候，不要将结构嵌套的太深。

2. 浏览器渲染引擎解析外部CSS样式文件或者直接以STYLE标签嵌入在HTML页面中的CSS样式数据，基于CSS样式构建一个CSS树


3. 基于DOM树和CSS树，浏览器渲染引擎会构建一个渲染树，也叫作Rander Tree
注意：构建出来的Rander Tree渲染树并不等同于DOM树,因为属性是display为none的元素和head里面的元素就不会构建成为渲染树。
CSS解析的时候是从右向左依次查找的，因为这样会最节省时间。

渲染树中包含了各个盒子，这些盒子包含了大小、颜色、位置等属性，并按照对应的顺序将这些盒子展示在屏幕上

4. 当渲染树构造完毕之后，此时浏览器已经知道了此HTML页面中有哪些节点、这些节点分别对应的CSS属性以及他们的从属关系，此时浏览器开始布局(Layout)的过程，顾名思义就是浏览器按照渲染树的信息计算出每一个DOM其精确的坐标，并根据坐标计算出这些DOM元素在屏幕上的位置。


5. 接下来就是浏览器渲染引擎绘制页面的过程，此时浏览器会去遍历rander Tree，并使用浏览器的UI后端层组件绘制会每一个节点，并将绘制的结果在屏幕上呈现给用户。
### 5.什么是回流和重绘？该如何去避免它？
回流：reflow 
当DOM中的一部分或全部部分因为尺寸大小、位置布局、隐藏显示这些因素导致浏览器需要重新进行构建渲染树的过程叫做回流，回流对于浏览器的渲染影响非常大，所以我们要尽可能的避免回流。

重绘：replain
当浏览器在渲染的时候，如果只是改变了某个DOM元素的文字颜色、背景颜色等这些不影响元素的位置布局的属性的时候，将只会引起浏览器的重绘，也就是重新绘制这一部分DOM元素。

哪些操作会产生回流和重绘？
1. 当我们通过JS去操作DOM元素并修改了DOM元素的位置、大小、隐藏等属性的时候
2. 页面初始化的时候
3. 当我们修改了某个元素所对应的CSS属性的时候
该如何去减少回流和重绘？
1. 不要一条条的修改DOM的样式，而是应该将这些需要改变的CSS样式统一写在一个class中，一次性的去应用这些改变，避免引起浏览器的多次回流。
2. 先将需要修改的DOM元素开启绝对定位position，因为这样会将DOM脱离文档流，此时修改元素的样式不会导致回流，等修改结束之后再变为原来的定位。
3. 不要使用table布局，而是用div+css的布局，这样一个结构更加语义化，而且table元素任意一个小的改动都会引起浏览器的回流。

### 说了这么多，那么如何去加快一个HTML页面的加载速度呢？
1. 首先页面的文件体积大小是很影响页面的速度的，所以：
+ 将html文档中多余的空格及注释都删除
+ 将css文件和js文件尽量采用外部样式表的方法引入，并且尽量做到能合并就合并，让页面在渲染的时候不要发起多个请求去下载多个css文件和js文件
+ 将js文件和css文件进行压缩瘦身
+ 把js文件但在页面body的元素最底端
+ 尽量用现代的css语法去代替浏览器请求图片，也就是精灵图的运用
+ 尽量用div+css布局，不用table布局，避免多次回流和重绘
2. 从DNS域名查询角度
+ 因为浏览器每发起一次请求都要进行域名查询的操作，所以尽量不要引入第三方的js或图片这些。
+ 在DNS进行域名查询的时候，尽量从浏览器的缓存cache中直接获取域名。

3. 从其他角度
+ 尽量让服务器距离用户近一些，因为传输数据越远时间越长
+ 写html的时候，不要把结构嵌套的太深，因为这会增加遍历DOM树的时间
+ 如果一个数据可以在后台处理，就不要拿到前端来通过js处理，比如二维码绘制这个问题，如果让后端直接绘制好带有参数的二维码，前端直接呈现要比前端自己绘制块的多

