{"version":3,"file":"reactivity.esm-bundler.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export const objectToString = Object.prototype.toString;\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value);\r\nexport const hasOwnProperty = Object.hasOwnProperty;\r\n\r\nexport const isObject = (value: any): boolean => {\r\n  return typeof value === \"object\" && value !== null;\r\n};\r\n\r\nexport const isPlainObject = (val: unknown) =>\r\n  toTypeString(val) === \"[object Object]\";\r\n\r\nexport const isFunction = (value: any): boolean => {\r\n  return typeof value === \"function\";\r\n};\r\n\r\nexport const isArray = Array.isArray;\r\n\r\nexport const isMap = (val: unknown) => toTypeString(val) === \"[object Map]\";\r\n\r\nexport const isSET = (val: unknown) => toTypeString(val) === \"[object Set]\";\r\n\r\nexport const isString = (val: unknown) =>\r\n  toTypeString(val) === \"[object String]\";\r\n\r\nexport const isNumber = (val: unknown) =>\r\n  toTypeString(val) === \"[object Number]\";\r\n\r\nexport const isBoolean = (val: unknown) =>\r\n  toTypeString(val) === \"[object Boolean]\";\r\n\r\nexport const hasOwn = (obj, key) => hasOwnProperty.call(obj, key);\r\n\r\n/**\r\n * @description 判断传入的属性名是否是一个数字类型的字符串 比如'0' '1' '10'都符合 但是'-1' 'name' 'NaN'不符合\r\n * @param key\r\n * @returns\r\n */\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== \"NaN\" &&\r\n  key[0] !== \"-\" &&\r\n  \"\" + parseInt(key as string, 10) === key;\r\n","import { isArray, isIntegerKey } from \"@gg-vue/shared\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\n\r\ntype Dep = Set<ReactiveEffect>;\r\n\r\ninterface ReactiveEffectOptions {\r\n  lazy?: boolean;\r\n  scheduler?: (job: ReactiveEffect) => void;\r\n  onTrack?: (event) => void;\r\n  onTrigger?: (event) => void;\r\n  onStop?: () => void;\r\n  allowRecurse?: boolean;\r\n}\r\n\r\ninterface ReactiveEffect<T = any> {\r\n  (): T;\r\n  _isEffect: true;\r\n  id: number;\r\n  active: boolean;\r\n  raw: () => T;\r\n  deps: Array<Dep>;\r\n  options: ReactiveEffectOptions;\r\n}\r\n\r\n/**\r\n * @description 响应式的核心实现effect函数\r\n * @param fn 回调函数\r\n *\r\n * 1. 默认会将传入的fn立即执行 如果是lazy 那么不会立即执行\r\n */\r\nexport function effect(fn, options: ReactiveEffectOptions = {}) {\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if (!options.lazy) {\r\n    effect();\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\n/**\r\n * @description 每次执行当前的effect重新渲染的时候 首先把存储的deps清空 避免重复执行effect\r\n * @param effect 当前执行的effect函数\r\n */\r\nfunction cleanup(effect) {\r\n  const { deps } = effect;\r\n  if (deps.length) {\r\n    for (const dep of deps) {\r\n      dep.delete(effect);\r\n    }\r\n    deps.length = 0;\r\n  }\r\n}\r\n\r\nlet uid = 0;\r\nlet activeEffect: ReactiveEffect<any>;\r\n// 栈结构主要是用于解决effect的嵌套执行 因为组件就是嵌套的\r\nconst effectStack: Array<ReactiveEffect> = [];\r\n\r\n/**\r\n * @description 创建一个effect副作用函数并返回 执行这个effect函数可以添加对内部响应式数据的主动观测\r\n * @param fn\r\n * @param options\r\n * @returns\r\n */\r\nfunction createReactiveEffect(\r\n  fn,\r\n  options: ReactiveEffectOptions\r\n): ReactiveEffect<any> {\r\n  const effect = function reactiveEffect() {\r\n    // 解决一个effect被无限循环执行 eg:effect(()=>{state.age++})\r\n    if (!effectStack.includes(effect)) {\r\n      // 每次执行前先做一个cleanup\r\n      cleanup(effect);\r\n\r\n      // 执行fn回调会去代理对象上取值 依赖收集就是在这里发生的\r\n      try {\r\n        effectStack.push(effect);\r\n        activeEffect = effect;\r\n        const res = fn();\r\n        return res; // 后续计算属性需要这个函数执行的结果\r\n      } finally {\r\n        effectStack.pop();\r\n        activeEffect = effectStack[effectStack.length - 1];\r\n      }\r\n    }\r\n  } as ReactiveEffect;\r\n\r\n  /* 给创建出来的effect打上标记 */\r\n  effect.id = uid++;\r\n  effect._isEffect = true;\r\n  effect.raw = fn;\r\n  effect.options = options;\r\n  effect.active = true;\r\n  effect.deps = [];\r\n\r\n  return effect;\r\n}\r\n\r\nconst targetMap = new WeakMap();\r\n/**\r\n * @description 属性的依赖收集\r\n * @param target 那个对象\r\n * @param type 属性收集的类型\r\n * @param key 那个属性\r\n */\r\nexport function track(target, type: TrackOpTypes, key) {\r\n  if (activeEffect === undefined) return;\r\n\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    depsMap = new Map();\r\n    targetMap.set(target, depsMap);\r\n  }\r\n\r\n  let dep = depsMap.get(key);\r\n  if (!dep) {\r\n    dep = new Set();\r\n    depsMap.set(key, dep);\r\n  }\r\n\r\n  if (!dep.has(activeEffect)) {\r\n    // 让属性记住依赖(组件)：更新当前target对象的key属性所收集的依赖Set集合 Set{effect1,effect2}\r\n    dep.add(activeEffect);\r\n    // 让依赖(组件)也记住属性:将当前这一刻的属性自身的dep也就是Set集合(存放着当前属性的所有依赖effect)\r\n    activeEffect.deps.push(dep);\r\n  }\r\n\r\n  console.log(\r\n    \"依赖收集完成一次，当前的targetMap是 === > \",\r\n    \"\\r\\n\",\r\n    target,\r\n    \"\\r\\n\",\r\n    key,\r\n    \"\\r\\n\",\r\n    targetMap\r\n  );\r\n}\r\n\r\n/**\r\n * @description 属性的更新通知\r\n * @param target\r\n * @param type\r\n * @param key\r\n * @param newValue\r\n * @param oldValue\r\n */\r\nexport function trigger(target, type, key?, newValue?, oldValue?) {\r\n  let depsMap = targetMap.get(target);\r\n  // 如果在weakMap依赖收集集合中找不到这个对象 说明没有被收集 那么不用更新\r\n  if (!depsMap) return;\r\n\r\n  // 新建一个Set集合用来存储本次更新的所有effect 目的是去重\r\n  const effects = new Set();\r\n\r\n  /**\r\n   * @description 专门用于更新时将属性key对应的dep 也就是Set集合都添加到统一的effects中\r\n   * @param effectToAdd\r\n   */\r\n  const add = (effectToAdd) => {\r\n    if (effectToAdd) {\r\n      // 遍历Set集合 然后依次添加\r\n      for (const effect of effectToAdd) {\r\n        effects.add(effect);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * 特殊处理1：关于数组length的更新\r\n   * 场景：如果在依赖收集的时候对于某个数组arr的length属性和索引属性都进行了收集，比如：\r\n   *  const state = reactive([100,200,300])\r\n   *  state[2] state.length 此时页面渲染：300和3\r\n   *\r\n   *  如果后续修改了length属性的值 此时就需要特殊处理，比如：\r\n   *  + state.length被修改为大于等于原来length的值\r\n   *    比如state.length = 5 此时只需要找到length收集的依赖进行更新\r\n   *  + state.length被修改为小于原来length的值\r\n   *    比如state.length = 0 此时不仅需要更新length依赖\r\n   *    还需从依赖集合中找到当前收集的所有数组索引属性比如'2' 然后更新相关依赖\r\n   *    因为数组的长度都变为0了 数组应该为空 此时页面应该为：undefined和0\r\n   *\r\n   */\r\n  if (key === \"length\" && isArray(target)) {\r\n    depsMap.forEach((dep, key) => {\r\n      // 这里的key可能是length 也可能是数字索引属性 newValue就是被新赋值的长度\r\n      if (key === \"length\" || key >= newValue) {\r\n        add(dep);\r\n      }\r\n    });\r\n  } else {\r\n    // 走到这里只能是：对象属性更新 或 数组索引属性更新\r\n    if (key !== undefined) {\r\n      add(depsMap.get(key));\r\n    }\r\n\r\n    /**\r\n     * 如果直接修改了数组的索引属性并因此修改了length,比如：\r\n     * const state = reactive([100,200,300])\r\n     * state.length 依赖收集 渲染3\r\n     *  state[100] = 0;\r\n     * 此时数组的length会变为100 需要触发length有关的依赖 渲染 100 200 300，，，，，，0\r\n     */\r\n    switch (type) {\r\n      case TraggerOpTypes.ADD:\r\n        if (isArray(target) && isIntegerKey(key)) {\r\n          add(depsMap.get(\"length\"));\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  // 触发更新 也就是取出当前属性key的每一个effect然后执行 再次更新的时候会重新去依赖收集触发getter并拿到更新后的值\r\n  // 在页面上的表现就是视图上绑定的依赖属性都发生了变化\r\n  effects.forEach((effect: any) => {\r\n    if (effect.options.scheduler) {\r\n      effect.options.scheduler(effect);\r\n    } else {\r\n      effect();\r\n    }\r\n  });\r\n}\r\n","/**\r\n * Notes:\r\n * 1. 避免写重复的radonl的setter 使用assign进行解耦\r\n * 2. 函数柯里化的思想\r\n * 3. 为什么用Reflect.get而不是target[key]\r\n *      + ES Next以后会将Object上的方法迁移到Reflect来\r\n *      + target[key]=value设置值就算设置失败也不会异常 但是Reflect设置值具有返回值\r\n *      + 解决源对象中有get访问器属性的时候修改源对象中name的值不引起响应式更新的bug\r\n * 4. Object.assign会修改第一个参数的值 很难注意到的bug\r\n */\r\n\r\nimport { isObject, isArray, isIntegerKey, hasOwn } from \"@gg-vue/shared\";\r\nimport {\r\n  readonly,\r\n  reactive,\r\n  ReactiveFlags,\r\n  reactiveMap,\r\n  readonlyMap,\r\n} from \"./reactive\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\nimport { track, trigger } from \"./effect\";\r\n\r\n/**\r\n * @description 创建一个get拦截函数并返回 依赖收集在此发生\r\n * @param isReadonly 是否只读\r\n * @param shallow 是否为浅劫持\r\n */\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target, key, receiver) {\r\n    if (\r\n      key === ReactiveFlags.RAW &&\r\n      receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)\r\n    ) {\r\n      return target;\r\n    }\r\n\r\n    const result = Reflect.get(target, key, receiver);\r\n\r\n    // 如果不是只读的 进行依赖收集\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key);\r\n    }\r\n\r\n    // 如果是浅收集 那么直接返回即可\r\n    if (shallow) {\r\n      return result;\r\n    }\r\n\r\n    /* \r\n        vue3.0的懒代理\r\n        + vue2.0是一上来就对对象进行递归劫持\r\n        + vue3.0是取值取到一个对象的时候才去代理\r\n    */\r\n    if (isObject(result)) {\r\n      return isReadonly ? readonly(result) : reactive(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * @description 创建一个set拦截函数并返回 通知更新在此发生 新增 - 修改 - 相等\r\n * @param shallow 是否为浅劫持\r\n */\r\nfunction createSetter(shallow = false) {\r\n  return function set(target, key, value, receiver) {\r\n    // 获取旧值\r\n    const oldValue = target[key];\r\n\r\n    /**\r\n     * 判断1：setter的时候是修改值还是新增值？\r\n     * 1. 如果target是数组并且key是有效索引 那么就判断修改的索引key是否小于数组长度 如果是那么就是修改 否则就是新增\r\n     * 2. 否则target就是对象 那么就判断当前对象target上是否存在属性key 如果存在就是修改 否则就是新增\r\n     * 3. Proxy的强大之处就是可以监控到任何修改数组和对象的行为 比如修改数组的索引和新增对象属性 在Vue2中要用$set方法实现\r\n     */\r\n\r\n    const isExistKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key);\r\n\r\n    // 获取设置后的返回值用于setter方法的返回值\r\n    const res = Reflect.set(target, key, value, receiver);\r\n\r\n    if (!isExistKey) {\r\n      // 走新增的更新\r\n      trigger(target, TraggerOpTypes.ADD, key, value);\r\n    } else if (oldValue !== value) {\r\n      // 走修改的更新\r\n      trigger(target, TraggerOpTypes.SET, key, value, oldValue);\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\n\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set,\r\n};\r\n\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSet,\r\n};\r\n\r\nexport const readonlyHandlers = {\r\n  get: readonlyGet,\r\n  set: (target, key) => {\r\n    console.warn(\r\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n      target\r\n    );\r\n    return true;\r\n  },\r\n};\r\n\r\nexport const shallowReadonlyHandlers = Object.assign({}, readonlyHandlers, {\r\n  get: shallowReadonlyGet,\r\n});\r\n","import {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers,\r\n} from \"./baseHandlers\";\r\n\r\nimport { isObject } from \"@gg-vue/shared\";\r\n\r\nexport function reactive(target) {\r\n  return createReactiveObject(target, false, mutableHandlers);\r\n}\r\n\r\nexport function shallowReactive(target) {\r\n  return createReactiveObject(target, false, shallowReactiveHandlers);\r\n}\r\n\r\nexport function readonly(target) {\r\n  return createReactiveObject(target, true, readonlyHandlers);\r\n}\r\n\r\nexport function shallowReadonly(target) {\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers);\r\n}\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = \"__v_skip\",\r\n  IS_REACTIVE = \"__v_isReactive\",\r\n  IS_READONLY = \"__v_isReadonly\",\r\n  RAW = \"__v_raw\",\r\n}\r\n\r\n// 存放响应代理的缓存 以target为key 以代理对象proxy为value\r\nexport const reactiveMap = new WeakMap();\r\n// 存放只读代理的缓存\r\nexport const readonlyMap = new WeakMap();\r\n\r\n/**\r\n *\r\n * @description 基于传入的target和isReadonly等配置创建一个Proxy响应式对象并返回\r\n * @param target 要代理的目标对象\r\n * @param isReadonly 是否只读\r\n * @param baseHandlers Proxy中的handles拦截器\r\n */\r\nfunction createReactiveObject(target, isReadonly, baseHandlers) {\r\n  // 只有目标是对象 才可以进行属性劫持\r\n  if (!isObject(target)) {\r\n    console.warn(`value cannot be made reactive: ${String(target)}`);\r\n    return target;\r\n  }\r\n\r\n  // 如果对象已经被代理过了 那么优先读取缓存 不进行重复的代理\r\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n  const existingProxy = proxyMap.get(target);\r\n  if (existingProxy) {\r\n    return existingProxy;\r\n  }\r\n\r\n  // 创建响应式对象\r\n  const proxy = new Proxy(target, baseHandlers);\r\n\r\n  proxyMap.set(target, proxy);\r\n  return proxy;\r\n}\r\n\r\nexport function toRaw(observed) {\r\n  return observed[ReactiveFlags.RAW] || observed;\r\n}\r\n\r\n/**\r\n * @description 将一个对象打上SKIP标记 以便于跳过响应式包装\r\n * @param value\r\n */\r\nexport function markRaw(value) {\r\n  Object.defineProperty(value, ReactiveFlags.SKIP, {\r\n    enumerable: false,\r\n    configurable: true,\r\n    value,\r\n  });\r\n  return value;\r\n}\r\n","/**\r\n * 将普通类型转化为一个对象\r\n * 这个对象有value属性指向原来的原始值\r\n * name.value\r\n * name.value = xxx;\r\n *\r\n */\r\nimport { isObject } from \"@gg-vue/shared\";\r\nimport { track, trigger } from \"./effect\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\nimport { reactive } from \"./reactive\";\r\n\r\n/**\r\n * @description 如果rawValue是一个对象 将其转化为响应式的对象后返回\r\n * @param rawValue 用户调用ref()时传入的值 可能是对象可能是基本值\r\n * @returns\r\n */\r\nfunction convert(rawValue) {\r\n  if (isObject(rawValue)) {\r\n    return reactive(rawValue);\r\n  } else {\r\n    return rawValue;\r\n  }\r\n}\r\n\r\n/**\r\n * 核心：ref和reactive的区别\r\n * reactive内部使用proxy实现拦截\r\n * ref内部使用类的访问器和取值器 其实编译之后就是definProperty实现拦截\r\n *\r\n * ref可以接受一个value的值为对象或者原始值\r\n * 返回的是一个RefImpl的实例\r\n */\r\nexport function ref(value) {\r\n  return createRef(value);\r\n}\r\n\r\nexport function shallowRef(value) {\r\n  return createRef(value, true);\r\n}\r\n\r\nfunction createRef(rawValue, shallow = false) {\r\n  return new RefImpl(rawValue, shallow);\r\n}\r\n\r\n/**\r\n * TypeScript的类\r\n * 1. 所有可以this.xxx访问的属性必须要在顶部通过public或privite声明\r\n * 2. 在ts类的构造器函数的参数中声明并添加public或privite声明，会默认执行：this.xxx = xxx的行为\r\n *    代表属性就被默认放到this实例上了\r\n */\r\nclass RefImpl {\r\n  public _value; // 取值和存值的时候公共操作的值 有可能是原始值 也有可能是Proxy后的值\r\n  public __v_isRef = true; // 标识是否为一个RefImpl实例\r\n\r\n  /**\r\n   *\r\n   * @param rawValue 永远暴露的是未被代理过的值\r\n   * @param shallow 是否浅劫持\r\n   */\r\n  constructor(public rawValue, public shallow) {\r\n    // 如果是浅劫持 就直接赋值即可 否则需要将每一层都转化为响应式的值\r\n    this._value = shallow ? rawValue : convert(rawValue);\r\n  }\r\n\r\n  /**\r\n   * @description 外部执行 state.value 进行依赖收集\r\n   */\r\n  get value() {\r\n    track(this, TrackOpTypes.GET, \"value\");\r\n    return this._value;\r\n  }\r\n\r\n  /**\r\n   * @description 外部执行 state.value = xxx 进行通知更新\r\n   */\r\n  set value(newValue) {\r\n    if (newValue !== this.rawValue) {\r\n      // 每次设置值的时候再次判断\r\n      this._value = this.shallow ? newValue : convert(newValue);\r\n      this.rawValue = newValue;\r\n      trigger(this, TraggerOpTypes.SET, \"value\", newValue);\r\n    }\r\n  }\r\n}\r\n\r\nexport function isRef(target) {\r\n  return Boolean(target?.__v_isRef === true);\r\n}\r\n\r\n/**\r\n *\r\n * @description 将target对象的key属性转换为一个Ref实例并返回 返回的ref和源对象target保持同步更改\r\n * 将targte[key]的访问形式 转化为 属性访问器.value的形式\r\n * @param target\r\n * @param key\r\n */\r\nexport function toRef(target, key) {\r\n  if (isRef(target[key])) {\r\n    return target[key];\r\n  } else {\r\n    // 这里其实很简单 就是对象引用值地址传递过去操作即可\r\n    return new ObjectRefImpl(target, key);\r\n  }\r\n}\r\n\r\n/**\r\n * @description 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref\r\n * @param target\r\n * @use 从组合式函数中返回响应式对象时，toRefs 相当有用 消费者组件可以解构/展开返回的对象而不会失去响应性：\r\n * 直接对一个reactive的对象进行解构会丢失响应式\r\n * 但是可以先对响应式对象执行toRefs操作将其转化为普通对象\r\n * 然后解构到每一个属性对应的值都是一个toRef的返回值就不会丢失响应式\r\n */\r\nexport function toRefs(target) {\r\n  const ret = Array.isArray(target) ? [] : {};\r\n  for (const key in target) {\r\n    ret[key] = toRef(target, key);\r\n  }\r\n  return ret;\r\n}\r\n\r\nclass ObjectRefImpl {\r\n  public __v_isRef = true;\r\n  constructor(public target, public key) {}\r\n\r\n  get value() {\r\n    return this.target[this.key];\r\n  }\r\n\r\n  set value(newValue) {\r\n    this.target[this.key] = newValue;\r\n  }\r\n}\r\n\r\nexport function unref(ref) {\r\n  return isRef(ref) ? ref.value : ref;\r\n}\r\n","import { isFunction } from \"@gg-vue/shared\";\r\nimport { effect, track, trigger } from \"./effect\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\n\r\nexport function computed(getterOrOptions) {\r\n  let getter;\r\n  let setter;\r\n\r\n  if (isFunction(getterOrOptions)) {\r\n    getter = getterOrOptions;\r\n    setter = () => {};\r\n  } else {\r\n    getter = getterOrOptions.get || (() => {});\r\n    setter = getterOrOptions.set || (() => {});\r\n  }\r\n\r\n  // 创建一个计算属性的实例\r\n  return new ComputedRefImpl(getter, setter);\r\n}\r\n\r\nclass ComputedRefImpl {\r\n  public _dirty = true;\r\n  public effect;\r\n  private _value;\r\n\r\n  constructor(getter, public setter) {\r\n    /**\r\n     * 将计算属性传入的getter看做是一个effect的fn 创建一个effect函数并返回\r\n     * effect有什么用呢？\r\n     * 执行effect可以执行包裹的fn也就是getter\r\n     * 执行getter的过程中会进行依赖收集\r\n     * 后续getter函数中用到的属性发生变化就可以触发属性更新\r\n     *\r\n     * lazy属性表示不会立即执行effect\r\n     * scheduler属性表示更新的时候不走默认执行effect逻辑 而是走scheduler调度器逻辑\r\n     * scheduler采用对象属性写法this是这个options对象\r\n     * scheduler采用箭头函数写法this是计算属性实例\r\n     */\r\n    this.effect = effect(getter, {\r\n      lazy: true,\r\n      scheduler: () => {\r\n        if (!this._dirty) {\r\n          this._dirty = true;\r\n        }\r\n        // 每次计算属性依赖的属性比如name变化了\r\n        // 需要通知依赖计算属性自己的上一层effect也更新\r\n        trigger(this, TraggerOpTypes.SET, \"value\");\r\n      },\r\n    });\r\n  }\r\n\r\n  get value() {\r\n    if (this._dirty) {\r\n      // effect执行的返回值就是getter的返回值\r\n      const res = this.effect();\r\n      this._value = res;\r\n      this._dirty = false;\r\n    }\r\n    // 计算属性实例可以把自己当做对象target 进行依赖收集\r\n    track(this, TrackOpTypes.GET, \"value\");\r\n    // 然后将值返回\r\n    return this._value;\r\n  }\r\n\r\n  //   计算属性不需要主动更新setter\r\n  set value(newValue) {\r\n    this.setter(newValue);\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}