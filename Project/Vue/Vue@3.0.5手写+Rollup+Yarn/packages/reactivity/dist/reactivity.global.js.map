{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export const objectToString = Object.prototype.toString;\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value);\r\nexport const hasOwnProperty = Object.hasOwnProperty;\r\n\r\nexport const isObject = (value: any): boolean => {\r\n  return typeof value === \"object\" && value !== null;\r\n};\r\n\r\nexport const isPlainObject = (val: unknown) =>\r\n  toTypeString(val) === \"[object Object]\";\r\n\r\nexport const isFunction = (value: any): boolean => {\r\n  return typeof value === \"function\";\r\n};\r\n\r\nexport const isArray = Array.isArray;\r\n\r\nexport const isMap = (val: unknown) => toTypeString(val) === \"[object Map]\";\r\n\r\nexport const isSET = (val: unknown) => toTypeString(val) === \"[object Set]\";\r\n\r\nexport const isString = (val: unknown) =>\r\n  toTypeString(val) === \"[object String]\";\r\n\r\nexport const isNumber = (val: unknown) =>\r\n  toTypeString(val) === \"[object Number]\";\r\n\r\nexport const isBoolean = (val: unknown) =>\r\n  toTypeString(val) === \"[object Boolean]\";\r\n\r\nexport const hasOwn = (obj, key) => hasOwnProperty.call(obj, key);\r\n\r\n/**\r\n * @description 判断传入的属性名是否是一个数字类型的字符串 比如'0' '1' '10'都符合 但是'-1' 'name' 'NaN'不符合\r\n * @param key\r\n * @returns\r\n */\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== \"NaN\" &&\r\n  key[0] !== \"-\" &&\r\n  \"\" + parseInt(key as string, 10) === key;\r\n","import { isArray, isIntegerKey } from \"@gg-vue/shared\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\n\r\ntype Dep = Set<ReactiveEffect>;\r\n\r\ninterface ReactiveEffectOptions {\r\n  lazy?: boolean;\r\n  scheduler?: (job: ReactiveEffect) => void;\r\n  onTrack?: (event) => void;\r\n  onTrigger?: (event) => void;\r\n  onStop?: () => void;\r\n  allowRecurse?: boolean;\r\n}\r\n\r\ninterface ReactiveEffect<T = any> {\r\n  (): T;\r\n  _isEffect: true;\r\n  id: number;\r\n  active: boolean;\r\n  raw: () => T;\r\n  deps: Array<Dep>;\r\n  options: ReactiveEffectOptions;\r\n}\r\n\r\n/**\r\n * @description 响应式的核心实现effect函数\r\n * @param fn 回调函数\r\n *\r\n * 1. 默认会将传入的fn立即执行 如果是lazy 那么不会立即执行\r\n */\r\nexport function effect(fn, options: ReactiveEffectOptions = {}) {\r\n  const effect = createReactiveEffect(fn, options);\r\n\r\n  if (!options.lazy) {\r\n    effect();\r\n  }\r\n\r\n  return effect;\r\n}\r\n\r\n/**\r\n * @description 每次执行当前的effect重新渲染的时候 首先把存储的deps清空 避免重复执行effect\r\n * @param effect 当前执行的effect函数\r\n */\r\nfunction cleanup(effect) {\r\n  const { deps } = effect;\r\n  if (deps.length) {\r\n    for (const dep of deps) {\r\n      dep.delete(effect);\r\n    }\r\n    deps.length = 0;\r\n  }\r\n}\r\n\r\nlet uid = 0;\r\nlet activeEffect: ReactiveEffect<any>;\r\n// 栈结构主要是用于解决effect的嵌套执行 因为组件就是嵌套的\r\nconst effectStack: Array<ReactiveEffect> = [];\r\n\r\n/**\r\n * @description 创建一个effect副作用函数并返回 执行这个effect函数可以添加对内部响应式数据的主动观测\r\n * @param fn\r\n * @param options\r\n * @returns\r\n */\r\nfunction createReactiveEffect(\r\n  fn,\r\n  options: ReactiveEffectOptions\r\n): ReactiveEffect<any> {\r\n  const effect = function reactiveEffect() {\r\n    // 解决一个effect被无限循环执行 eg:effect(()=>{state.age++})\r\n    if (!effectStack.includes(effect)) {\r\n      // 每次执行前先做一个cleanup\r\n      cleanup(effect);\r\n\r\n      // 执行fn回调会去代理对象上取值 依赖收集就是在这里发生的\r\n      try {\r\n        effectStack.push(effect);\r\n        activeEffect = effect;\r\n        const res = fn();\r\n        return res; // 后续计算属性需要这个函数执行的结果\r\n      } finally {\r\n        effectStack.pop();\r\n        activeEffect = effectStack[effectStack.length - 1];\r\n      }\r\n    }\r\n  } as ReactiveEffect;\r\n\r\n  /* 给创建出来的effect打上标记 */\r\n  effect.id = uid++;\r\n  effect._isEffect = true;\r\n  effect.raw = fn;\r\n  effect.options = options;\r\n  effect.active = true;\r\n  effect.deps = [];\r\n\r\n  return effect;\r\n}\r\n\r\nconst targetMap = new WeakMap();\r\n/**\r\n * @description 属性的依赖收集\r\n * @param target 那个对象\r\n * @param type 属性收集的类型\r\n * @param key 那个属性\r\n */\r\nexport function track(target, type: TrackOpTypes, key) {\r\n  if (activeEffect === undefined) return;\r\n\r\n  let depsMap = targetMap.get(target);\r\n  if (!depsMap) {\r\n    depsMap = new Map();\r\n    targetMap.set(target, depsMap);\r\n  }\r\n\r\n  let dep = depsMap.get(key);\r\n  if (!dep) {\r\n    dep = new Set();\r\n    depsMap.set(key, dep);\r\n  }\r\n\r\n  if (!dep.has(activeEffect)) {\r\n    // 让属性记住依赖(组件)：更新当前target对象的key属性所收集的依赖Set集合 Set{effect1,effect2}\r\n    dep.add(activeEffect);\r\n    // 让依赖(组件)也记住属性:将当前这一刻的属性自身的dep也就是Set集合(存放着当前属性的所有依赖effect)\r\n    activeEffect.deps.push(dep);\r\n  }\r\n\r\n  console.log(\r\n    \"依赖收集完成一次，当前的targetMap是 === > \",\r\n    \"\\r\\n\",\r\n    target,\r\n    \"\\r\\n\",\r\n    key,\r\n    \"\\r\\n\",\r\n    targetMap\r\n  );\r\n}\r\n\r\n/**\r\n * @description 属性的更新通知\r\n * @param target\r\n * @param type\r\n * @param key\r\n * @param newValue\r\n * @param oldValue\r\n */\r\nexport function trigger(target, type, key?, newValue?, oldValue?) {\r\n  let depsMap = targetMap.get(target);\r\n  // 如果在weakMap依赖收集集合中找不到这个对象 说明没有被收集 那么不用更新\r\n  if (!depsMap) return;\r\n\r\n  // 新建一个Set集合用来存储本次更新的所有effect 目的是去重\r\n  const effects = new Set();\r\n\r\n  /**\r\n   * @description 专门用于更新时将属性key对应的dep 也就是Set集合都添加到统一的effects中\r\n   * @param effectToAdd\r\n   */\r\n  const add = (effectToAdd) => {\r\n    if (effectToAdd) {\r\n      // 遍历Set集合 然后依次添加\r\n      for (const effect of effectToAdd) {\r\n        effects.add(effect);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * 特殊处理1：关于数组length的更新\r\n   * 场景：如果在依赖收集的时候对于某个数组arr的length属性和索引属性都进行了收集，比如：\r\n   *  const state = reactive([100,200,300])\r\n   *  state[2] state.length 此时页面渲染：300和3\r\n   *\r\n   *  如果后续修改了length属性的值 此时就需要特殊处理，比如：\r\n   *  + state.length被修改为大于等于原来length的值\r\n   *    比如state.length = 5 此时只需要找到length收集的依赖进行更新\r\n   *  + state.length被修改为小于原来length的值\r\n   *    比如state.length = 0 此时不仅需要更新length依赖\r\n   *    还需从依赖集合中找到当前收集的所有数组索引属性比如'2' 然后更新相关依赖\r\n   *    因为数组的长度都变为0了 数组应该为空 此时页面应该为：undefined和0\r\n   *\r\n   */\r\n  if (key === \"length\" && isArray(target)) {\r\n    depsMap.forEach((dep, key) => {\r\n      // 这里的key可能是length 也可能是数字索引属性 newValue就是被新赋值的长度\r\n      if (key === \"length\" || key >= newValue) {\r\n        add(dep);\r\n      }\r\n    });\r\n  } else {\r\n    // 走到这里只能是：对象属性更新 或 数组索引属性更新\r\n    if (key !== undefined) {\r\n      add(depsMap.get(key));\r\n    }\r\n\r\n    /**\r\n     * 如果直接修改了数组的索引属性并因此修改了length,比如：\r\n     * const state = reactive([100,200,300])\r\n     * state.length 依赖收集 渲染3\r\n     *  state[100] = 0;\r\n     * 此时数组的length会变为100 需要触发length有关的依赖 渲染 100 200 300，，，，，，0\r\n     */\r\n    switch (type) {\r\n      case TraggerOpTypes.ADD:\r\n        if (isArray(target) && isIntegerKey(key)) {\r\n          add(depsMap.get(\"length\"));\r\n        }\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  // 触发更新 也就是取出当前属性key的每一个effect然后执行 再次更新的时候会重新去依赖收集触发getter并拿到更新后的值\r\n  // 在页面上的表现就是视图上绑定的依赖属性都发生了变化\r\n  effects.forEach((effect: any) => {\r\n    if (effect.options.scheduler) {\r\n      effect.options.scheduler(effect);\r\n    } else {\r\n      effect();\r\n    }\r\n  });\r\n}\r\n","/**\r\n * Notes:\r\n * 1. 避免写重复的radonl的setter 使用assign进行解耦\r\n * 2. 函数柯里化的思想\r\n * 3. 为什么用Reflect.get而不是target[key]\r\n *      + ES Next以后会将Object上的方法迁移到Reflect来\r\n *      + target[key]=value设置值就算设置失败也不会异常 但是Reflect设置值具有返回值\r\n *      + 解决源对象中有get访问器属性的时候修改源对象中name的值不引起响应式更新的bug\r\n * 4. Object.assign会修改第一个参数的值 很难注意到的bug\r\n */\r\n\r\nimport { isObject, isArray, isIntegerKey, hasOwn } from \"@gg-vue/shared\";\r\nimport {\r\n  readonly,\r\n  reactive,\r\n  ReactiveFlags,\r\n  reactiveMap,\r\n  readonlyMap,\r\n} from \"./reactive\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\nimport { track, trigger } from \"./effect\";\r\n\r\n/**\r\n * @description 创建一个get拦截函数并返回 依赖收集在此发生\r\n * @param isReadonly 是否只读\r\n * @param shallow 是否为浅劫持\r\n */\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n  return function get(target, key, receiver) {\r\n    if (\r\n      key === ReactiveFlags.RAW &&\r\n      receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)\r\n    ) {\r\n      return target;\r\n    }\r\n\r\n    const result = Reflect.get(target, key, receiver);\r\n\r\n    // 如果不是只读的 进行依赖收集\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key);\r\n    }\r\n\r\n    // 如果是浅收集 那么直接返回即可\r\n    if (shallow) {\r\n      return result;\r\n    }\r\n\r\n    /* \r\n        vue3.0的懒代理\r\n        + vue2.0是一上来就对对象进行递归劫持\r\n        + vue3.0是取值取到一个对象的时候才去代理\r\n    */\r\n    if (isObject(result)) {\r\n      return isReadonly ? readonly(result) : reactive(result);\r\n    }\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * @description 创建一个set拦截函数并返回 通知更新在此发生 新增 - 修改 - 相等\r\n * @param shallow 是否为浅劫持\r\n */\r\nfunction createSetter(shallow = false) {\r\n  return function set(target, key, value, receiver) {\r\n    // 获取旧值\r\n    const oldValue = target[key];\r\n\r\n    /**\r\n     * 判断1：setter的时候是修改值还是新增值？\r\n     * 1. 如果target是数组并且key是有效索引 那么就判断修改的索引key是否小于数组长度 如果是那么就是修改 否则就是新增\r\n     * 2. 否则target就是对象 那么就判断当前对象target上是否存在属性key 如果存在就是修改 否则就是新增\r\n     * 3. Proxy的强大之处就是可以监控到任何修改数组和对象的行为 比如修改数组的索引和新增对象属性 在Vue2中要用$set方法实现\r\n     */\r\n\r\n    const isExistKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key);\r\n\r\n    // 获取设置后的返回值用于setter方法的返回值\r\n    const res = Reflect.set(target, key, value, receiver);\r\n\r\n    if (!isExistKey) {\r\n      // 走新增的更新\r\n      trigger(target, TraggerOpTypes.ADD, key, value);\r\n    } else if (oldValue !== value) {\r\n      // 走修改的更新\r\n      trigger(target, TraggerOpTypes.SET, key, value, oldValue);\r\n    }\r\n\r\n    return res;\r\n  };\r\n}\r\n\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\n\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\n\r\nexport const mutableHandlers = {\r\n  get,\r\n  set,\r\n};\r\n\r\nexport const shallowReactiveHandlers = {\r\n  get: shallowGet,\r\n  set: shallowSet,\r\n};\r\n\r\nexport const readonlyHandlers = {\r\n  get: readonlyGet,\r\n  set: (target, key) => {\r\n    console.warn(\r\n      `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n      target\r\n    );\r\n    return true;\r\n  },\r\n};\r\n\r\nexport const shallowReadonlyHandlers = Object.assign({}, readonlyHandlers, {\r\n  get: shallowReadonlyGet,\r\n});\r\n","import {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers,\r\n} from \"./baseHandlers\";\r\n\r\nimport { isObject } from \"@gg-vue/shared\";\r\n\r\nexport function reactive(target) {\r\n  return createReactiveObject(target, false, mutableHandlers);\r\n}\r\n\r\nexport function shallowReactive(target) {\r\n  return createReactiveObject(target, false, shallowReactiveHandlers);\r\n}\r\n\r\nexport function readonly(target) {\r\n  return createReactiveObject(target, true, readonlyHandlers);\r\n}\r\n\r\nexport function shallowReadonly(target) {\r\n  return createReactiveObject(target, true, shallowReadonlyHandlers);\r\n}\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = \"__v_skip\",\r\n  IS_REACTIVE = \"__v_isReactive\",\r\n  IS_READONLY = \"__v_isReadonly\",\r\n  RAW = \"__v_raw\",\r\n}\r\n\r\n// 存放响应代理的缓存 以target为key 以代理对象proxy为value\r\nexport const reactiveMap = new WeakMap();\r\n// 存放只读代理的缓存\r\nexport const readonlyMap = new WeakMap();\r\n\r\n/**\r\n *\r\n * @description 基于传入的target和isReadonly等配置创建一个Proxy响应式对象并返回\r\n * @param target 要代理的目标对象\r\n * @param isReadonly 是否只读\r\n * @param baseHandlers Proxy中的handles拦截器\r\n */\r\nfunction createReactiveObject(target, isReadonly, baseHandlers) {\r\n  // 只有目标是对象 才可以进行属性劫持\r\n  if (!isObject(target)) {\r\n    console.warn(`value cannot be made reactive: ${String(target)}`);\r\n    return target;\r\n  }\r\n\r\n  // 如果对象已经被代理过了 那么优先读取缓存 不进行重复的代理\r\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n  const existingProxy = proxyMap.get(target);\r\n  if (existingProxy) {\r\n    return existingProxy;\r\n  }\r\n\r\n  // 创建响应式对象\r\n  const proxy = new Proxy(target, baseHandlers);\r\n\r\n  proxyMap.set(target, proxy);\r\n  return proxy;\r\n}\r\n\r\nexport function toRaw(observed) {\r\n  return observed[ReactiveFlags.RAW] || observed;\r\n}\r\n\r\n/**\r\n * @description 将一个对象打上SKIP标记 以便于跳过响应式包装\r\n * @param value\r\n */\r\nexport function markRaw(value) {\r\n  Object.defineProperty(value, ReactiveFlags.SKIP, {\r\n    enumerable: false,\r\n    configurable: true,\r\n    value,\r\n  });\r\n  return value;\r\n}\r\n","/**\r\n * 将普通类型转化为一个对象\r\n * 这个对象有value属性指向原来的原始值\r\n * name.value\r\n * name.value = xxx;\r\n *\r\n */\r\nimport { isObject } from \"@gg-vue/shared\";\r\nimport { track, trigger } from \"./effect\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\nimport { reactive } from \"./reactive\";\r\n\r\n/**\r\n * @description 如果rawValue是一个对象 将其转化为响应式的对象后返回\r\n * @param rawValue 用户调用ref()时传入的值 可能是对象可能是基本值\r\n * @returns\r\n */\r\nfunction convert(rawValue) {\r\n  if (isObject(rawValue)) {\r\n    return reactive(rawValue);\r\n  } else {\r\n    return rawValue;\r\n  }\r\n}\r\n\r\n/**\r\n * 核心：ref和reactive的区别\r\n * reactive内部使用proxy实现拦截\r\n * ref内部使用类的访问器和取值器 其实编译之后就是definProperty实现拦截\r\n *\r\n * ref可以接受一个value的值为对象或者原始值\r\n * 返回的是一个RefImpl的实例\r\n */\r\nexport function ref(value) {\r\n  return createRef(value);\r\n}\r\n\r\nexport function shallowRef(value) {\r\n  return createRef(value, true);\r\n}\r\n\r\nfunction createRef(rawValue, shallow = false) {\r\n  return new RefImpl(rawValue, shallow);\r\n}\r\n\r\n/**\r\n * TypeScript的类\r\n * 1. 所有可以this.xxx访问的属性必须要在顶部通过public或privite声明\r\n * 2. 在ts类的构造器函数的参数中声明并添加public或privite声明，会默认执行：this.xxx = xxx的行为\r\n *    代表属性就被默认放到this实例上了\r\n */\r\nclass RefImpl {\r\n  public _value; // 取值和存值的时候公共操作的值 有可能是原始值 也有可能是Proxy后的值\r\n  public __v_isRef = true; // 标识是否为一个RefImpl实例\r\n\r\n  /**\r\n   *\r\n   * @param rawValue 永远暴露的是未被代理过的值\r\n   * @param shallow 是否浅劫持\r\n   */\r\n  constructor(public rawValue, public shallow) {\r\n    // 如果是浅劫持 就直接赋值即可 否则需要将每一层都转化为响应式的值\r\n    this._value = shallow ? rawValue : convert(rawValue);\r\n  }\r\n\r\n  /**\r\n   * @description 外部执行 state.value 进行依赖收集\r\n   */\r\n  get value() {\r\n    track(this, TrackOpTypes.GET, \"value\");\r\n    return this._value;\r\n  }\r\n\r\n  /**\r\n   * @description 外部执行 state.value = xxx 进行通知更新\r\n   */\r\n  set value(newValue) {\r\n    if (newValue !== this.rawValue) {\r\n      // 每次设置值的时候再次判断\r\n      this._value = this.shallow ? newValue : convert(newValue);\r\n      this.rawValue = newValue;\r\n      trigger(this, TraggerOpTypes.SET, \"value\", newValue);\r\n    }\r\n  }\r\n}\r\n\r\nexport function isRef(target) {\r\n  return Boolean(target?.__v_isRef === true);\r\n}\r\n\r\n/**\r\n *\r\n * @description 将target对象的key属性转换为一个Ref实例并返回 返回的ref和源对象target保持同步更改\r\n * 将targte[key]的访问形式 转化为 属性访问器.value的形式\r\n * @param target\r\n * @param key\r\n */\r\nexport function toRef(target, key) {\r\n  if (isRef(target[key])) {\r\n    return target[key];\r\n  } else {\r\n    // 这里其实很简单 就是对象引用值地址传递过去操作即可\r\n    return new ObjectRefImpl(target, key);\r\n  }\r\n}\r\n\r\n/**\r\n * @description 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref\r\n * @param target\r\n * @use 从组合式函数中返回响应式对象时，toRefs 相当有用 消费者组件可以解构/展开返回的对象而不会失去响应性：\r\n * 直接对一个reactive的对象进行解构会丢失响应式\r\n * 但是可以先对响应式对象执行toRefs操作将其转化为普通对象\r\n * 然后解构到每一个属性对应的值都是一个toRef的返回值就不会丢失响应式\r\n */\r\nexport function toRefs(target) {\r\n  const ret = Array.isArray(target) ? [] : {};\r\n  for (const key in target) {\r\n    ret[key] = toRef(target, key);\r\n  }\r\n  return ret;\r\n}\r\n\r\nclass ObjectRefImpl {\r\n  public __v_isRef = true;\r\n  constructor(public target, public key) {}\r\n\r\n  get value() {\r\n    return this.target[this.key];\r\n  }\r\n\r\n  set value(newValue) {\r\n    this.target[this.key] = newValue;\r\n  }\r\n}\r\n\r\nexport function unref(ref) {\r\n  return isRef(ref) ? ref.value : ref;\r\n}\r\n","import { isFunction } from \"@gg-vue/shared\";\r\nimport { effect, track, trigger } from \"./effect\";\r\nimport { TrackOpTypes, TraggerOpTypes } from \"./operations\";\r\n\r\nexport function computed(getterOrOptions) {\r\n  let getter;\r\n  let setter;\r\n\r\n  if (isFunction(getterOrOptions)) {\r\n    getter = getterOrOptions;\r\n    setter = () => {};\r\n  } else {\r\n    getter = getterOrOptions.get || (() => {});\r\n    setter = getterOrOptions.set || (() => {});\r\n  }\r\n\r\n  // 创建一个计算属性的实例\r\n  return new ComputedRefImpl(getter, setter);\r\n}\r\n\r\nclass ComputedRefImpl {\r\n  public _dirty = true;\r\n  public effect;\r\n  private _value;\r\n\r\n  constructor(getter, public setter) {\r\n    /**\r\n     * 将计算属性传入的getter看做是一个effect的fn 创建一个effect函数并返回\r\n     * effect有什么用呢？\r\n     * 执行effect可以执行包裹的fn也就是getter\r\n     * 执行getter的过程中会进行依赖收集\r\n     * 后续getter函数中用到的属性发生变化就可以触发属性更新\r\n     *\r\n     * lazy属性表示不会立即执行effect\r\n     * scheduler属性表示更新的时候不走默认执行effect逻辑 而是走scheduler调度器逻辑\r\n     * scheduler采用对象属性写法this是这个options对象\r\n     * scheduler采用箭头函数写法this是计算属性实例\r\n     */\r\n    this.effect = effect(getter, {\r\n      lazy: true,\r\n      scheduler: () => {\r\n        if (!this._dirty) {\r\n          this._dirty = true;\r\n        }\r\n        // 每次计算属性依赖的属性比如name变化了\r\n        // 需要通知依赖计算属性自己的上一层effect也更新\r\n        trigger(this, TraggerOpTypes.SET, \"value\");\r\n      },\r\n    });\r\n  }\r\n\r\n  get value() {\r\n    if (this._dirty) {\r\n      // effect执行的返回值就是getter的返回值\r\n      const res = this.effect();\r\n      this._value = res;\r\n      this._dirty = false;\r\n    }\r\n    // 计算属性实例可以把自己当做对象target 进行依赖收集\r\n    track(this, TrackOpTypes.GET, \"value\");\r\n    // 然后将值返回\r\n    return this._value;\r\n  }\r\n\r\n  //   计算属性不需要主动更新setter\r\n  set value(newValue) {\r\n    this.setter(newValue);\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;EAAO,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;EACjD,MAAM,YAAY,GAAG,CAAC,KAAc,KACzC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;EACtB,MAAM,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC;EAE7C,MAAM,QAAQ,GAAG,CAAC,KAAU;MACjC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,CAAC;EACrD,CAAC,CAAC;EAKK,MAAM,UAAU,GAAG,CAAC,KAAU;MACnC,OAAO,OAAO,KAAK,KAAK,UAAU,CAAC;EACrC,CAAC,CAAC;EAEK,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;EAM9B,MAAM,QAAQ,GAAG,CAAC,GAAY,KACnC,YAAY,CAAC,GAAG,CAAC,KAAK,iBAAiB,CAAC;EAQnC,MAAM,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,KAAK,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAElE;;;;;EAKO,MAAM,YAAY,GAAG,CAAC,GAAY,KACvC,QAAQ,CAAC,GAAG,CAAC;MACb,GAAG,KAAK,KAAK;MACb,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG;MACd,EAAE,GAAG,QAAQ,CAAC,GAAa,EAAE,EAAE,CAAC,KAAK,GAAG;;EClB1C;;;;;;WAMgB,MAAM,CAAC,EAAE,EAAE,UAAiC,EAAE;MAC5D,MAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;MAEjD,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;UACjB,MAAM,EAAE,CAAC;OACV;MAED,OAAO,MAAM,CAAC;EAChB,CAAC;EAED;;;;EAIA,SAAS,OAAO,CAAC,MAAM;MACrB,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;MACxB,IAAI,IAAI,CAAC,MAAM,EAAE;UACf,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;cACtB,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;WACpB;UACD,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;OACjB;EACH,CAAC;EAED,IAAI,GAAG,GAAG,CAAC,CAAC;EACZ,IAAI,YAAiC,CAAC;EACtC;EACA,MAAM,WAAW,GAA0B,EAAE,CAAC;EAE9C;;;;;;EAMA,SAAS,oBAAoB,CAC3B,EAAE,EACF,OAA8B;MAE9B,MAAM,MAAM,GAAG,SAAS,cAAc;;UAEpC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;;cAEjC,OAAO,CAAC,MAAM,CAAC,CAAC;;cAGhB,IAAI;kBACF,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;kBACzB,YAAY,GAAG,MAAM,CAAC;kBACtB,MAAM,GAAG,GAAG,EAAE,EAAE,CAAC;kBACjB,OAAO,GAAG,CAAC;eACZ;sBAAS;kBACR,WAAW,CAAC,GAAG,EAAE,CAAC;kBAClB,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;eACpD;WACF;OACgB,CAAC;;MAGpB,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE,CAAC;MAClB,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC;MACxB,MAAM,CAAC,GAAG,GAAG,EAAE,CAAC;MAChB,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;MACzB,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC;MACrB,MAAM,CAAC,IAAI,GAAG,EAAE,CAAC;MAEjB,OAAO,MAAM,CAAC;EAChB,CAAC;EAED,MAAM,SAAS,GAAG,IAAI,OAAO,EAAE,CAAC;EAChC;;;;;;WAMgB,KAAK,CAAC,MAAM,EAAE,IAAkB,EAAE,GAAG;MACnD,IAAI,YAAY,KAAK,SAAS;UAAE,OAAO;MAEvC,IAAI,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;MACpC,IAAI,CAAC,OAAO,EAAE;UACZ,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;UACpB,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;OAChC;MAED,IAAI,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAC3B,IAAI,CAAC,GAAG,EAAE;UACR,GAAG,GAAG,IAAI,GAAG,EAAE,CAAC;UAChB,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;OACvB;MAED,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;;UAE1B,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;;UAEtB,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;OAC7B;MAED,OAAO,CAAC,GAAG,CACT,+BAA+B,EAC/B,MAAM,EACN,MAAM,EACN,MAAM,EACN,GAAG,EACH,MAAM,EACN,SAAS,CACV,CAAC;EACJ,CAAC;EAED;;;;;;;;WAQgB,OAAO,CAAC,MAAM,EAAE,IAAI,EAAE,GAAI,EAAE,QAAS,EAAE,QAAS;MAC9D,IAAI,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;;MAEpC,IAAI,CAAC,OAAO;UAAE,OAAO;;MAGrB,MAAM,OAAO,GAAG,IAAI,GAAG,EAAE,CAAC;;;;;MAM1B,MAAM,GAAG,GAAG,CAAC,WAAW;UACtB,IAAI,WAAW,EAAE;;cAEf,KAAK,MAAM,MAAM,IAAI,WAAW,EAAE;kBAChC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;eACrB;WACF;OACF,CAAC;;;;;;;;;;;;;;;;MAiBF,IAAI,GAAG,KAAK,QAAQ,IAAI,OAAO,CAAC,MAAM,CAAC,EAAE;UACvC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG;;cAEvB,IAAI,GAAG,KAAK,QAAQ,IAAI,GAAG,IAAI,QAAQ,EAAE;kBACvC,GAAG,CAAC,GAAG,CAAC,CAAC;eACV;WACF,CAAC,CAAC;OACJ;WAAM;;UAEL,IAAI,GAAG,KAAK,SAAS,EAAE;cACrB,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;WACvB;;;;;;;;UASD,QAAQ,IAAI;cACV;kBACE,IAAI,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;sBACxC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;mBAC5B;kBACD,MAAM;WAIT;OACF;;;MAID,OAAO,CAAC,OAAO,CAAC,CAAC,MAAW;UAC1B,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE;cAC5B,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;WAClC;eAAM;cACL,MAAM,EAAE,CAAC;WACV;OACF,CAAC,CAAC;EACL;;EChOA;;;;;;;;;;EAsBA;;;;;EAKA,SAAS,YAAY,CAAC,UAAU,GAAG,KAAK,EAAE,OAAO,GAAG,KAAK;MACvD,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ;UACvC,IACE,GAAG;cACH,QAAQ,KAAK,CAAC,UAAU,GAAG,WAAW,GAAG,WAAW,EAAE,GAAG,CAAC,MAAM,CAAC,EACjE;cACA,OAAO,MAAM,CAAC;WACf;UAED,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;;UAGlD,IAAI,CAAC,UAAU,EAAE;cACf,KAAK,CAAC,MAAM,mBAAoB,GAAG,CAAC,CAAC;WACtC;;UAGD,IAAI,OAAO,EAAE;cACX,OAAO,MAAM,CAAC;WACf;;;;;;UAOD,IAAI,QAAQ,CAAC,MAAM,CAAC,EAAE;cACpB,OAAO,UAAU,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;WACzD;UAED,OAAO,MAAM,CAAC;OACf,CAAC;EACJ,CAAC;EAED;;;;EAIA,SAAS,YAAY,CAAC,OAAO,GAAG,KAAK;MACnC,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;;UAE9C,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;;;;;;;UAS7B,MAAM,UAAU,GACd,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC;gBAChC,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM;gBAC3B,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;;UAG1B,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;UAEtD,IAAI,CAAC,UAAU,EAAE;;cAEf,OAAO,CAAC,MAAM,mBAAsB,GAAG,EAAE,KAAK,CAAC,CAAC;WACjD;eAAM,IAAI,QAAQ,KAAK,KAAK,EAAE;;cAE7B,OAAO,CAAC,MAAM,mBAAsB,GAAG,EAAE,KAAe,CAAC,CAAC;WAC3D;UAED,OAAO,GAAG,CAAC;OACZ,CAAC;EACJ,CAAC;EAED,MAAM,GAAG,GAAG,YAAY,EAAE,CAAC;EAC3B,MAAM,UAAU,GAAG,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;EAC7C,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;EACvC,MAAM,kBAAkB,GAAG,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;EAEpD,MAAM,GAAG,GAAG,YAAY,EAAE,CAAC;EAC3B,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;EAE/B,MAAM,eAAe,GAAG;MAC7B,GAAG;MACH,GAAG;GACJ,CAAC;EAEK,MAAM,uBAAuB,GAAG;MACrC,GAAG,EAAE,UAAU;MACf,GAAG,EAAE,UAAU;GAChB,CAAC;EAEK,MAAM,gBAAgB,GAAG;MAC9B,GAAG,EAAE,WAAW;MAChB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG;UACf,OAAO,CAAC,IAAI,CACV,yBAAyB,MAAM,CAAC,GAAG,CAAC,+BAA+B,EACnE,MAAM,CACP,CAAC;UACF,OAAO,IAAI,CAAC;OACb;GACF,CAAC;EAEK,MAAM,uBAAuB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,gBAAgB,EAAE;MACzE,GAAG,EAAE,kBAAkB;GACxB,CAAC;;WCvHc,QAAQ,CAAC,MAAM;MAC7B,OAAO,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;EAC9D,CAAC;WAEe,eAAe,CAAC,MAAM;MACpC,OAAO,oBAAoB,CAAC,MAAM,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;EACtE,CAAC;WAEe,QAAQ,CAAC,MAAM;MAC7B,OAAO,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,gBAAgB,CAAC,CAAC;EAC9D,CAAC;WAEe,eAAe,CAAC,MAAM;MACpC,OAAO,oBAAoB,CAAC,MAAM,EAAE,IAAI,EAAE,uBAAuB,CAAC,CAAC;EACrE,CAAC;EASD;EACO,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;EACzC;EACO,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;EAEzC;;;;;;;EAOA,SAAS,oBAAoB,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY;;MAE5D,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;UACrB,OAAO,CAAC,IAAI,CAAC,kCAAkC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;UACjE,OAAO,MAAM,CAAC;OACf;;MAGD,MAAM,QAAQ,GAAG,UAAU,GAAG,WAAW,GAAG,WAAW,CAAC;MACxD,MAAM,aAAa,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;MAC3C,IAAI,aAAa,EAAE;UACjB,OAAO,aAAa,CAAC;OACtB;;MAGD,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;MAE9C,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;MAC5B,OAAO,KAAK,CAAC;EACf;;EC/DA;;;;;;;EAYA;;;;;EAKA,SAAS,OAAO,CAAC,QAAQ;MACvB,IAAI,QAAQ,CAAC,QAAQ,CAAC,EAAE;UACtB,OAAO,QAAQ,CAAC,QAAQ,CAAC,CAAC;OAC3B;WAAM;UACL,OAAO,QAAQ,CAAC;OACjB;EACH,CAAC;EAED;;;;;;;;WAQgB,GAAG,CAAC,KAAK;MACvB,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;EAC1B,CAAC;WAEe,UAAU,CAAC,KAAK;MAC9B,OAAO,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;EAChC,CAAC;EAED,SAAS,SAAS,CAAC,QAAQ,EAAE,OAAO,GAAG,KAAK;MAC1C,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;EACxC,CAAC;EAED;;;;;;EAMA,MAAM,OAAO;;;;;;MASX,YAAmB,QAAQ,EAAS,OAAO;UAAxB,aAAQ,GAAR,QAAQ,CAAA;UAAS,YAAO,GAAP,OAAO,CAAA;UAPpC,cAAS,GAAG,IAAI,CAAC;;UAStB,IAAI,CAAC,MAAM,GAAG,OAAO,GAAG,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;OACtD;;;;MAKD,IAAI,KAAK;UACP,KAAK,CAAC,IAAI,mBAAoB,OAAO,CAAC,CAAC;UACvC,OAAO,IAAI,CAAC,MAAM,CAAC;OACpB;;;;MAKD,IAAI,KAAK,CAAC,QAAQ;UAChB,IAAI,QAAQ,KAAK,IAAI,CAAC,QAAQ,EAAE;;cAE9B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;cAC1D,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;cACzB,OAAO,CAAC,IAAI,mBAAsB,OAAO,EAAE,QAAQ,CAAC,CAAC;WACtD;OACF;GACF;WAEe,KAAK,CAAC,MAAM;MAC1B,OAAO,OAAO,CAAC,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,SAAS,MAAK,IAAI,CAAC,CAAC;EAC7C,CAAC;EAED;;;;;;;WAOgB,KAAK,CAAC,MAAM,EAAE,GAAG;MAC/B,IAAI,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE;UACtB,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;OACpB;WAAM;;UAEL,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;OACvC;EACH,CAAC;EAED;;;;;;;;WAQgB,MAAM,CAAC,MAAM;MAC3B,MAAM,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC;MAC5C,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;UACxB,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;OAC/B;MACD,OAAO,GAAG,CAAC;EACb,CAAC;EAED,MAAM,aAAa;MAEjB,YAAmB,MAAM,EAAS,GAAG;UAAlB,WAAM,GAAN,MAAM,CAAA;UAAS,QAAG,GAAH,GAAG,CAAA;UAD9B,cAAS,GAAG,IAAI,CAAC;OACiB;MAEzC,IAAI,KAAK;UACP,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;OAC9B;MAED,IAAI,KAAK,CAAC,QAAQ;UAChB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;OAClC;GACF;WAEe,KAAK,CAAC,GAAG;MACvB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC;EACtC;;WCrIgB,QAAQ,CAAC,eAAe;MACtC,IAAI,MAAM,CAAC;MACX,IAAI,MAAM,CAAC;MAEX,IAAI,UAAU,CAAC,eAAe,CAAC,EAAE;UAC/B,MAAM,GAAG,eAAe,CAAC;UACzB,MAAM,GAAG,SAAQ,CAAC;OACnB;WAAM;UACL,MAAM,GAAG,eAAe,CAAC,GAAG,KAAK,SAAQ,CAAC,CAAC;UAC3C,MAAM,GAAG,eAAe,CAAC,GAAG,KAAK,SAAQ,CAAC,CAAC;OAC5C;;MAGD,OAAO,IAAI,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;EAC7C,CAAC;EAED,MAAM,eAAe;MAKnB,YAAY,MAAM,EAAS,MAAM;UAAN,WAAM,GAAN,MAAM,CAAA;UAJ1B,WAAM,GAAG,IAAI,CAAC;;;;;;;;;;;;;UAiBnB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE;cAC3B,IAAI,EAAE,IAAI;cACV,SAAS,EAAE;kBACT,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;sBAChB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;mBACpB;;;kBAGD,OAAO,CAAC,IAAI,mBAAsB,OAAO,CAAC,CAAC;eAC5C;WACF,CAAC,CAAC;OACJ;MAED,IAAI,KAAK;UACP,IAAI,IAAI,CAAC,MAAM,EAAE;;cAEf,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;cAC1B,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC;cAClB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;WACrB;;UAED,KAAK,CAAC,IAAI,mBAAoB,OAAO,CAAC,CAAC;;UAEvC,OAAO,IAAI,CAAC,MAAM,CAAC;OACpB;;MAGD,IAAI,KAAK,CAAC,QAAQ;UAChB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;OACvB;;;;;;;;;;;;;;;;;;;;;;;;;;"}