<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /* 
        二进制技巧总结: 
        1. 给你一个十进制的数字num,要求你打印或者取出任意第i位的二进制状态是0还是1?
        num >> i & 1 == 0 ? 0:1
        1是固定的数字:000000000....001
        num需要将要对比的这一位数字向右滚动到和1对对齐:10000......0001
        因为1的其他位都是0,所以按位与的数字是1那么就返回1,如果是0就返回0
        注意不能写成:num >> i & 1 == 1 ? 1:0
        这是因为num >> i & 1 最终得到的是一个十进制的数字往往是大于1的,所以不要这样判断
        1按位与num右移i位

        2. 已知一个数字的二进制的第i位置的值是1,如何创建一个变量来保存这一位的状态?
        0 | (1 << i )
        0是固定的数字
        你不是第i位的值想克隆一份吗,我先把1向左位移到和你第i位重叠的地方那么:
        000000000000000000
        000000000010000000
        两者按位或不就等于把那个数字的第i位克隆一份了吗
        然后可以在返回值的基础上继续按位或 就可以把一个数字克隆出来

        你可能会问直接赋值不好吗?
        问题是我现在不知道这个数的第多少位是1,必须一个个遍历的过程种才发现符合条件的i
        然后一个个的把i还原到一个数字,就是这种0按位或1左移i的方法
    */
    </script>
    <script>
      /* 
            假设数组中有1种数字出现小于m次，其余数都出现了m次
            找出出现小于m次的那个数？
        */
      function findNum(arr, m) {
        const list = new Array(32).fill(0);
        /* 
            记录0位上有多少个1
            记录1位上有多少个1
            记录x位上有多少个1

            00000010 2
            00000010 2
            00000011 3
            00000010 2

            list: 0 0 0 0 0 0 4 1
            list种第0位有1一个1,第2位有4个1

        */
        for (const num of arr) {
          // 给你一个数字num,如何知道这个数字的每一位都是0还是1?
          for (let i = 0; i < list.length; i++) {
            // (10010000 >> 0) & 00000001 => 0 所以第0位就是0
            // (10010000 >> 1) & 00000001 => 0 所以第1位就是0
            // (10010000 >> 4) & 00000001 => 1 所以第4位就是1
            let bitValue = (num >> i) & 1;
            list[i] += bitValue;
          }
        }

        let ans = 0;
        for (let i = 0; i < list.length; i++) {
          if (list[i] % m !== 0) {
            // 说明那个答案的数字这一位就是1
            // 那么如何还原出ans的二进制状态呢 用按位或
            // 已知:某一个二进制的状态位第i位是1,如果获取到一个第i位是1其余位是0的数字
            // 先把1向左移动i位和第i位对其,然后取或运算,由于是或运算不会改变原来数的
            ans = ans | (1 << i);
            // 00000000
            // 00000010
            // 00000100
            // 00000110
          }
        }

        return ans;
      }

      console.log(findNum([2, 2, 3, 2], 3));
    </script>
  </body>
</html>
