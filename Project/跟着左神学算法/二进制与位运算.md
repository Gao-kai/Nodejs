# 二进制与位运算

## 基本概念

假设有一个 4 位的二进制数：

1. 如何是无符号的表达，那么总共可以表示 2 的 4 次方个二进制数字，范围为 0 到 2 的 4 次方-1
2. 如何是带符号的表达，那么总共可以表示 2 的 4 次方个二进制数字

   - 负数部分范围为负的 2 的 4-1 次方到-1，总计表示 2 的 3 次方个数字
   - 非负数部分范围为 0 到正的 2 的 3 次方-1，总计表示 2 的 3 次方个数字

## 正数和负数在计算机中二进制表达

有符号的二进制，4 位可以表达多少个数字呢？还是 16 个，但是数字分配就不一样了：
第一个位为 0，表示非负数，因此 0 包含在内

- 0000 0
- 0001 1
- 0010 2
- 0011 3
- 0100 4
- 0101 5
- 0110 6
- 0111 7

第一个位为 1，表示负数，负数的 1 可不是 1001，而是分为以下几个步骤进行：

1. 首先拿到要表示的负数的正数的二进制表示，1 的二进制是 0001
2. 然后将这个值取反，也就是~，得到二进制的 1110
3. 然后将这个二进制+1，也就是 1111，这个 1111 就是有符号的-1 在二进制的表达

按照上面的结论，我们可以写出另外的从-7 到-1 的所有二进制数字：

- 1111 -1
- 1110 -2
- 1101 -3
- 1100 -4
- 1011 -5
- 1010 -6
- 1001 -7

## 16 进制的本质

0123456789abcdef

1. 计算机中 4 位最多可以表达 16 个数字，也就是说任意一个 4 位表达的二进制都可以用一个 16 进制的数字表示
2. 比如 11000011，前 4 位表示 10 进制的 12，16 进制的就是 c，后 4 位表示 10 进制的 5，也就是 16 进制的 5
3. 合并起来就是 0xc5

## 实现一个打印二进制的方法：Number.toString(redix)

```js
/**
 * 1. 1 << i可以得到一个以1开头，后面是i个0的二进制数字
 * 2. 拿这个数字和任意一个数字做按位与运算，如果返回结果为0，那么这个数字num的第i位的值一定是0，否则一定是1
 * 3. 但是不能写：(num & (1 << i)) === 1 ? "1" : "0" 这是因为就算0010和(1<<1)做按位与运算，得到的也是0010也就是2的1次方，而不是1
 */
function numToBinaryString(num) {
  let binaryString = "";
  for (let i = 7; i >= 0; i--) {
    let s = (num & (1 << i)) === 0 ? "0" : "1";
    binaryString += s;
  }
  return binaryString;
}

console.log(numToBinaryString(5));
console.log(numToBinaryString(10));
console.log(numToBinaryString(128));
console.log(numToBinaryString(255));
```

## JavaScript 中直接定义数字的方法

1. 十进制数字直接声明
2. 2 进制数字以 0b 开头
3. 8 进制数字以 0o 开头
4. 16 进制数字以 0x 开头
5. Number.parseInt(binaryString,2) 2 进制转化为 10 进制的数字
6. Number.prototype.toString(2) 10 进制的数字转化为 2 进制的字符串

## JavaScript 中的位运算

1. 按位与 &
   两个位的值都为 1 对应位才是 1
2. 按位或 |
   任意一个位的值位 1 就是 1
3. 按位异或 ^
   两个位的值相同返回 0，不同返回 1
4. 按位非 也叫做取反~
   将每一个对应位的值取反，0 变为 1，1 变为 0
5. 左移 <<
   将一个数的二进制表示向左移动固定的位数,每左移 1 位，表示在原来基础上乘以 2，只适用于非负数
   0100 << 1 => 1000
   0001 << 2 => 0100
6. 右移 >>
   将一个数的二进制表示向右移动固定的位数,每右移 1 位，表示在原来基础上除以 2 然后向下取整，只适用于非负数
   0100 >> 1 => 0010
   0100 >> 2 => 0001

## 如何快速求一个二进制数的相反数

比如一个二进制的正数 0100，表示为 正数的 4

1. 取反变为 1011
2. +1 变为 1100
3. 1100 在计算机中表示的负数时多少呢？
4. 1100 先全部取反 0011
5. 然后-1 变为 0100，前面加上负号就是-4

## 为什么二进制的负数这样设计？

为了加法的统一一套逻辑，不需要条件转移
保证了底层运算的快速和搞笑
